#!/usr/bin/perl  -w

use strict;
use warnings;

#this perl script is used to generate Closure
#huicanzhu
#bradzhang

my $kPreMaxArgs = 10;
my $kMaxArgs = 10;

sub PrintHead()
{
    print "// Copyright (c) 2010, Tencent Inc. All rights reserved.\n\n";
    print "#ifndef COMMON_BASE_CLOSURE_H_\n";
    print "#define COMMON_BASE_CLOSURE_H_\n\n";
    print "\n/////////////////////////////////////////////////////\n";
    print "// DO NOT EDIT!!!\n";
    print "// this header file is auto generated by perl script\n";
    print "// edit the generator if necessary\n";
    print "/////////////////////////////////////////////////////\n\n";

    print "// closure.h\n";
    print "//\n";
    print "// huican zhu\n";
    print "// wookin\n";
    print "// phongchen\n";
    print "// bradzhang\n";
    print "//\n";
    print "// GLOBAL_NOLINT(whitespace/line_length)\n";
    print "// ///////////////////////////////////////////\n";

    print "// 普通无返回值 Closure\n";

    for (my $i = 0; $i <= $kMaxArgs; $i++)
    {
        print "// Closure: x->Run(";
        for (my $j = 1; $j <= $i; ++$j)
        {
            print "arg$j";
            print ", " if ($j < $i);
        }

        print "), Closure 可预设 0-${kPreMaxArgs} 个参数\n";
    }

    print "//\n";

    print "// 返回值为 R 的 Closure\n";

    for (my $i = 0; $i <= $kMaxArgs; $i++)
    {
        print "// Closure: R = x->Run(";
        for (my $j = 1; $j <= $i; ++$j)
        {
            print "arg$j";
            print ", " if ($j < $i);
        }
        print "), Closure 可预设 0-${kPreMaxArgs} 个参数\n";
    }

    print "//\n";
    print "//////////////////////////////////////\n\n";
}

sub PrintEnd
{
    print "\n#endif // COMMON_BASE_CLOSURE_H_\n";
}

sub PrintClosureBase()
{
    print "
/// base class for all Closures
class ClosureBase
{
public:
    virtual ~ClosureBase() {}
    virtual bool IsSelfDelete() const = 0;
};

";
}

sub PrintClosure()
{
    my $kTotalArgs = $kPreMaxArgs + $kMaxArgs;
    print "// primary template\n";
    print "template <\n    typename R";

    my ($i);
    for ($i = 1; $i <= $kTotalArgs; $i++)
    {
        print ",\n    typename Arg$i = void";
    }

    print "\n>\n";
    print "class Closure : public ClosureBase\n";
    print "{\n";
    print "public:\n";
    print "    virtual R Run(\n";

    for ($i = 1; $i <= $kTotalArgs; $i++)
    {
        print "        Arg$i arg$i";

        if ($i != $kTotalArgs)
        {
            print ",";
        }

        print "\n";
    }

    print "    ) = 0;\n";
    print "};\n\n";

    for ($i = 0; $i < $kTotalArgs; $i++)
    {
        if ($i <= 1)
        {
            print "\n// specified for $i argument\n";
        }
        else
        {
            print "\n// specified for $i arguments\n";
        }

        print "template <typename R";

        my ($j);
        for ($j = 1; $j <= $i; ++$j)
        {
            print ", typename Arg$j";
        }

        print ">\n";
        print "class Closure<R";

        for ($j = 1; $j <= $i; ++$j)
        {
            print ", Arg$j";
        }

        print "> : public ClosureBase\n{\npublic:\n";
        print "    virtual R Run(";

        for ($j = 1; $j <= $i; ++$j)
        {
            print "Arg$j arg$j";

            if ($j != $i)
            {
                print ", ";
            }
        }

        print ") = 0;\n";
        print "};\n";
    }
}

sub PrintConditionalAutoDeleter()
{
    print "
//////////////////////////////////////////////////
// helper ////////////////////////////////////////
//////////////////////////////////////////////////

// delete p in dtor automatically if Enabled is true
template <bool Enabled, typename T>
class ConditionalAutoDeleter
{
public:
    explicit ConditionalAutoDeleter(T* p)
        : m_p(p)
    {
    }
    ~ConditionalAutoDeleter()
    {
        delete m_p;
    }
private:
    ConditionalAutoDeleter(const ConditionalAutoDeleter&);
    ConditionalAutoDeleter& operator=(const ConditionalAutoDeleter&);
private:
    T* m_p;
};

template <typename T>
class ConditionalAutoDeleter<false, T>
{
public:
    explicit ConditionalAutoDeleter(T* p)
    {
    }
private:
    ConditionalAutoDeleter(const ConditionalAutoDeleter&);
    ConditionalAutoDeleter& operator=(const ConditionalAutoDeleter&);
};

"
}

sub PrintClosure_Arg_Bind($$$)
{
    my ($type, $num_pre_args, $num_args) = @_;
    my $k;

    # print template argument list
    print "template <\n    bool SelfDeleting,\n    typename R";
    print ",\n    typename Class" if ($type eq "Method");
    for ($k = 1; $k <= $num_pre_args; $k++)
    {
        print ",\n    typename PreArg$k";
    }
    for ($k = 1; $k <= $num_args; $k++)
    {
        print ",\n    typename Arg$k";
    }
    print "\n>\n";

    # print class definition
    my $ClassName = "${type}Closure_Arg${num_args}_Bind${num_pre_args}";
    print "class ${ClassName} : public Closure<R";
    for ($k = 1; $k <= $num_args; $k++)
    {
        print ", Arg$k";
    }
    print "> {\n";

    # print typedef
    print "    typedef R (";
    print "Class::" if ($type eq "Method");
    print "*${type}Type)(";

    for ($k = 1; $k <= $num_pre_args; $k++)
    {
        print "PreArg$k";
        print ", " if ($k < $num_pre_args || $num_args > 0);
    }

    for ($k = 1; $k <= $num_args; $k++)
    {
        print "Arg$k";
        print ", " if ($k < $num_args);
    }

    print ");\n";

    print "public:\n";

    # print ctor
    print "    ";
    print "explicit " if $type eq "Function" && $num_pre_args == 0;
    print "$ClassName(";

    if ($type eq "Method")
    {
        print "Class *object, MethodType method";
    }
    elsif ($type eq "Function")
    {
        print "FunctionType function";
    }

    for ($k = 1; $k <= $num_pre_args; $k++)
    {
        print ", PreArg$k pa$k";
    }
    print "):\n        ";

    if ($type eq "Method")
    {
        print "m_object(object), m_method(method)";
    }
    elsif ($type eq "Function")
    {
        print "m_function(function)";
    }

    for ($k = 1; $k <= $num_pre_args; $k++)
    {
        print ", m_pa${k}(pa${k})";
    }
    print " {}\n";

    # print the `Run' function
    print "    virtual R Run(";
    for ($k = 1; $k <= $num_args; $k++)
    {
        print "Arg${k} arg${k}";
        print ", " if ($k < $num_args);
    }
    print ") {\n";
    print "        ConditionalAutoDeleter<SelfDeleting, ${ClassName}> self_deleter(this);\n";
    print "        return ";
    if ($type eq "Method")
    {
        print "(m_object->*m_method)(";
    }
    elsif ($type eq "Function")
    {
        print "m_function(";
    }
    for ($k = 1; $k <= $num_pre_args; $k++)
    {
        print "m_pa$k";
        print ", " if $k != $num_pre_args || $num_args > 0;
    }
    for ($k = 1; $k <= $num_args; $k++)
    {
            print "arg$k";
            print ", " if $k != $num_args;
    }
    print ");\n";
    print "    }\n";

    # IsSelfDelete
    print "    virtual bool IsSelfDelete() const { return SelfDeleting; }\n";

    # member variables
    print "private:\n";
    if ($type eq "Method")
    {
            print "    Class* m_object;\n    MethodType m_method;\n";
    }
    if ($type eq "Function")
    {
            print "    FunctionType m_function;\n";
    }
    for ($k = 1; $k <= $num_pre_args; $k++)
    {
            print "    PreArg${k} m_pa${k};\n";
    }
    print "};\n\n";
}

sub PrintAllClosure_Arg_Binds($)
{
    my ($type) = @_;
    print "////////////////////////////////////////////////////\n";

    if ($type eq "Method")
    {
        print "//////////// class method closures /////////////////\n";
    }
    else
    {
        print "//////////// nomal function closures //////////////////\n";
    }
    print "////////////////////////////////////////////////////\n\n";

    for (my $num_args = 0; $num_args <= $kMaxArgs; ++$num_args)
    {
        for (my $num_pre_args = 0; $num_pre_args <= $kPreMaxArgs; $num_pre_args++)
        {
            PrintClosure_Arg_Bind($type, $num_pre_args, $num_args);
        }
    }
}

sub PrintNewClosure($$)
{
    my ($type, $self_deleting) = @_;
    print "////////////////////////////////////////////////////\n";
    print "//////// Closure create helper functions /////////////\n";
    print "////////////////////////////////////////////////////\n";
    if ($type eq "Method")
    {
        print "//////////// for class method ////////////////////////\n\n";
    }
    else
    {
        print "//////////// for nomal function ////////////////////////\n\n";
    }

    # $resultType = $has_result ? "R" : "void";
    for (my $num_args = 0; $num_args <= $kMaxArgs; $num_args++)
    {
        for (my $num_pre_args = 0; $num_pre_args <= $kPreMaxArgs; $num_pre_args++)
        {
            my $k;
            print "template <typename R";
            print ", typename Class" if ($type eq "Method");
            for ($k = 1; $k <= $num_pre_args; $k++)
            {
                print ", typename PreArg$k";
            }
            for ($k = 1; $k <= $num_args; $k++)
            {
                print ", typename Arg$k";
            }
            print ">\n";
            print "Closure<R";
            for ($k = 1; $k <= $num_args; $k++)
            {
                print ", Arg$k";
            }
            print ">*";
            if ($self_deleting eq "false")
            {
                print "NewPermanentClosure(";
            }
            else
            {
                print "NewClosure(";
            }
            if ($type eq "Method")
            {
                print "Class *object, R (Class::*method)(";
            }
            else
            {
                print "R (*function)(";
            }
            for ($k = 1; $k <= $num_pre_args; $k++)
            {
                print "PreArg$k";
                print ", " if ($k < $num_pre_args || $num_args > 0);
            }
            for ($k = 1; $k <= $num_args; $k++)
            {
                print "Arg$k";
                print ", " if ($k < $num_args);
            }
            print ")";
            for ($k = 1; $k <= $num_pre_args; $k++)
            {
                print ", PreArg$k pa$k";
            }
            print ") {\n";

            if ($type eq "Method")
            {
                print "    return new MethodClosure_Arg${num_args}_Bind${num_pre_args}<$self_deleting, R, Class";
            }
            else
            {
                print "    return new FunctionClosure_Arg${num_args}_Bind${num_pre_args}<$self_deleting, R";
            }
            for ($k = 1; $k <= $num_pre_args; $k++)
            {
                print ", PreArg$k";
            }
            for ($k = 1; $k <= $num_args; $k++)
            {
                print ", Arg$k";
            }
            print ">(";
            if ($type eq "Method")
            {
                print "object, method";
            }
            else
            {
                print "function";
            }
            for ($k = 1; $k <= $num_pre_args; $k++)
            {
                print ", pa$k";
            }
            print ");\n}\n\n";
        }
    }
}

# Start real work
PrintHead();
PrintClosureBase();
PrintClosure();
PrintConditionalAutoDeleter();
PrintAllClosure_Arg_Binds("Method");
PrintAllClosure_Arg_Binds("Function");
PrintNewClosure("Method", "true");
PrintNewClosure("Method", "false");
PrintNewClosure("Function", "true");
PrintNewClosure("Function", "false");
PrintEnd();

