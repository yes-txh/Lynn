$$ This is a pump file for generating file templates.  Pump is a python
$$ script that is part of the Google Test suite of utilities.  Description
$$ can be found here:
$$ http://code.google.com/p/googletest/wiki/PumpManual

$var MAX_ARITY = 8

// Copyright (c) 2011, Tencent Inc.
// All rights reserved.
//
// Author: CHEN Feng <phongchen@tencent.com>
// Created: 05/10/11

#ifndef COMMON_BASE_FUNCTION_FUNCTION_HPP
#define COMMON_BASE_FUNCTION_FUNCTION_HPP
#pragma once

#include <assert.h>
#include "common/base/function/function_base.hpp"
#include "common/base/function/param_traits.hpp"

// GLOBAL_NOLINT(whitespace/parens)
// GLOBAL_NOLINT(runtime/explicit)

namespace base {

// First, we forward declare the Function class template. This informs the
// compiler that the template only has 1 type parameter which is the function
// signature that the Function is representing.
//
// After this, create template specializations for 0-$(MAX_ARITY) parameters. Note that
// even though the template typelist grows, the specialization still
// only has one type: the function signature.
template <typename Signature>
class Function;


$range ARITY 0..MAX_ARITY
$for ARITY [[
$range ARG 1..ARITY

$if ARITY == 0 [[
template <typename R>
class Function<R (void)> : public internal::FunctionBase
{
]] $else [[
template <
    typename R,
    $for ARG ,
    [[typename A$(ARG)]]

>
class Function<R ($for ARG , [[A$(ARG)]])> :
    public internal::FunctionBase
{
]]

private:
    typedef R (*PolymorphicInvoke)(internal::InvokerStorageBase*$if ARITY != 0 [[,]]
        $for ARG,
        [[typename internal::ParamTraits<A$(ARG)>::ForwardType]]

    );

public:
    Function(FunctionBase::ClearType* p = NULL) : FunctionBase(NULL, NULL)
    {
        assert(p == NULL);
    }

    // We pass InvokerStorageHolder by const ref to avoid incurring an
    // unnecessary AddRef/Unref pair even though we will modify the object.
    // We cannot use a normal reference because the compiler will warn
    // since this is often used on a return value, which is a temporary.
    //
    // Note that this constructor CANNOT be explicit, and that Bind() CANNOT
    // return the exact Function<> type.  See base/bind.h for details.
    template <typename T>
    Function(const internal::InvokerStorageHolder<T>& invoker_holder) :
        FunctionBase(
            reinterpret_cast<InvokeFuncStorage>(&T::Invoker::DoInvoke),
            &invoker_holder.m_invoker_storage
        )
    {
        CheckSignatureConsistency(&T::Invoker::DoInvoke);
    }

    R operator()(
        $for ARG,
        [[typename internal::ParamTraits<A$(ARG)>::ForwardType a$(ARG)]]

    ) const
    {
        PolymorphicInvoke f =
            reinterpret_cast<PolymorphicInvoke>(m_polymorphic_invoke);

        return f(
            m_invoker_storage.get()[[]]
$if ARITY != 0 [[, ]]
$for ARG ,
            [[a$(ARG)]]

        );
    }

    bool operator==(const Function& rhs) const
    {
        return this->IsEqualTo(rhs);
    }

    Function& operator=(FunctionBase::ClearType* p)
    {
        assert(p == NULL);
        this->Clear();
        return *this;
    }

    void Swap(Function* other)
    {
        this->DoSwap(other);
    }

private:
    // inconsist param type may cause compiling error
    static void CheckSignatureConsistency(PolymorphicInvoke) {}
};


]]  $$ for ARITY

// the following is taken from
// /usr/local/gcc4.5.1/include/c++/4.5.1/tr1/functional

// [3.7.2.7] null pointer comparisons

///  @brief Compares a polymorphic function object wrapper against 0
///  (the NULL pointer).
///  @returns @c true if the wrapper has no target, @c false otherwise
///
///  This function will not throw an %exception.
template<typename Signature>
inline bool operator==(
    const Function<Signature>& f,
    internal::FunctionBase::ClearType*)
{
    return !static_cast<bool>(f);
}

/// @overload
template<typename Signature>
inline bool operator==(
    internal::FunctionBase::ClearType*,
    const Function<Signature>& f)
{
    return !static_cast<bool>(f);
}

/// @brief Compares a polymorphic function object wrapper against 0
/// (the NULL pointer).
/// @returns @c false if the wrapper has no target, @c true otherwise
///
/// This function will not throw an %exception.
template<typename Signature>
inline bool operator!=(
    const Function<Signature>& f,
    internal::FunctionBase::ClearType*)
{
    return static_cast<bool>(f);
}

/// @overload
template<typename Signature>
inline bool operator!=(
    internal::FunctionBase::ClearType*,
    const Function<Signature>& f)
{
    return static_cast<bool>(f);
}

}  // namespace base

// [3.7.2.8] specialized algorithms

// fit to STL
namespace std
{
/// @brief Swap the targets of two polymorphic function object wrappers.
///
/// This function will not throw an %exception.
template<typename Signature>
inline void swap(::base::Function<Signature>& x, ::base::Function<Signature>& y)
{
    x.Swap(&y);
}
} // namespace std

#endif // COMMON_BASE_FUNCTION_FUNCTION_HPP
