$$ This is a pump file for generating file templates.  Pump is a python
$$ script that is part of the Google Test suite of utilities.  Description
$$ can be found here:
$$ http://code.google.com/p/googletest/wiki/PumpManual

$var MAX_ARITY = 8

// Copyright (c) 2011, Tencent Inc.
// All rights reserved.
//
// Author: CHEN Feng <phongchen@tencent.com>
// Created: 05/09/11
// Description: InvokerN

#ifndef COMMON_BASE_FUNCTION_INVOKER_STORAGE_HPP
#define COMMON_BASE_FUNCTION_INVOKER_STORAGE_HPP
#pragma once

#include "common/base/function/invoker_storage_base.hpp"
#include "common/base/function/param_traits.hpp"
#include "common/base/function/param_check.hpp"
#include "common/base/function/param_annotation.hpp"
#include "common/base/function/function_traits.hpp"

namespace base {
namespace internal {

// The method by which a function is invoked is determined by 3 different
// dimensions:
//
//   1) The type of function (normal or method).
//   2) The arity of the function.
//   3) The number of bound parameters.
//
// The templates below handle the determination of each of these dimensions.
// In brief:
//
//   FunctionTraits<> -- Provides a normalied signature, and other traits.
//   InvokerN<> -- Provides a DoInvoke() function that actually executes
//                 a calback.
//   InvokerStorageN<> -- Provides storage for the bound parameters, and
//                        typedefs to the above.
//
// More details about the design of each class is included in a comment closer
// to their defition.


// InvokerN<>
//
// The InvokerN templates contain a static DoInvoke() function that is the key
// to implementing type erasure in the Function() classes.
//
// DoInvoke() is a static function with a fixed signature that is independent
// of StorageType; its first argument is a pointer to the non-templated common
// baseclass of StorageType. This lets us store pointer to DoInvoke() in a
// function pointer that has knowledge of the specific StorageType, and thus
// no knowledge of the bound function and bound parameter types.
//
// As long as we ensure that DoInvoke() is only used with pointers there were
// upcasted from the correct StorageType, we can be sure that execution is
// safe.
//
// The InvokerN templates are the only point that knows the number of bound
// and unbound arguments.  This is intentional because it allows the other
// templates classes in the system to only have as many specializations as
// the max arity of function we wish to support.

$range BOUND 0..MAX_ARITY
$for BOUND [[

template <typename StorageType, typename NormalizedSignature>
struct Invoker$(BOUND);

$range ARITY 0..MAX_ARITY
$for ARITY [[

$var UNBOUND = ARITY - BOUND
$if UNBOUND >= 0 [[

$$ Variables for function traits generation.
$range ARG 1..ARITY
$range BOUND_ARG 1..BOUND
$range UNBOUND_ARG (ARITY - UNBOUND + 1)..ARITY

$$ Variables for method traits generation. We are always short one arity since
$$ the first bound parameter is the object.
$var M_ARITY = ARITY - 1
$range M_ARG 1..M_ARITY
$range M_BOUND_ARG 2..BOUND
$range M_UNBOUND_ARG (M_ARITY - UNBOUND + 1)..M_ARITY

// Function: Arity $(ARITY) -> $(UNBOUND).
template <
    typename StorageType,
    typename R$if ARITY > 0 [[, ]][[]]
$for ARG,
    [[typename X$(ARG)]]

>
struct Invoker$(BOUND)<StorageType, R (*)($for ARG , [[X$(ARG)]])>
{
    static R DoInvoke(InvokerStorageBase* base[[]]
$if UNBOUND != 0 [[, ]][[]]
$for UNBOUND_ARG , [[typename internal::ParamTraits<X$(UNBOUND_ARG)>::ForwardType x$(UNBOUND_ARG)]])
    {
        StorageType* invoker = static_cast<StorageType*>(base);
        return invoker->function($for BOUND_ARG, [[Unwrap(invoker->m_p$(BOUND_ARG))]][[]]
$$ Add comma if there are both boudn and unbound args.
$if UNBOUND > 0 [[$if BOUND > 0 [[, ]]]][[]]
$for UNBOUND_ARG , [[x$(UNBOUND_ARG)]]);
    }
};

$if BOUND > 0 [[

// Method: Arity $(M_ARITY) -> $(UNBOUND).
template <
    typename StorageType,
    typename R,
    typename T$if M_ARITY > 0[[,]][[]]

    $for M_ARG,
    [[typename X$(M_ARG)]]

>
struct Invoker$(BOUND)<StorageType, R (T::*)($for M_ARG , [[X$(M_ARG)]])>
{
    static R DoInvoke(InvokerStorageBase* base[[]]
$if UNBOUND > 0 [[, ]][[]]
$for M_UNBOUND_ARG , [[typename internal::ParamTraits<X$(M_UNBOUND_ARG)>::ForwardType x$(M_UNBOUND_ARG)]])
    {
        StorageType* invoker = static_cast<StorageType*>(base);
        return (Unwrap(invoker->m_p1)->*invoker->function)([[]]
$for M_BOUND_ARG , [[Unwrap(invoker->m_p$(M_BOUND_ARG))]][[]]
$if UNBOUND > 0 [[$if BOUND > 1 [[, ]]]][[]]
$for M_UNBOUND_ARG , [[x$(M_UNBOUND_ARG)]]);
    }
};

]]  $$ if BOUND

]]  $$ if UNBOUND
]]  $$ for ARITY
]]  $$ for BOUND


// InvokerStorageN<>
//
// These are the actual storage classes for the Invokers.
//
// Though these types are "classes", they are being used as structs with
// all member variable public.  We cannot make it a struct because it inherits
// from a class which causes a compiler warning.  We cannot add a "Run()" method
// that forwards the unbound arguments because that would require we unwrap the
// Signature type like in InvokerN above to know the return type, and the arity
// of Run().
//
// An alternate solution would be to merge InvokerN and InvokerStorageN,
// but the generated code seemed harder to read.

$for BOUND [[
$range BOUND_ARG 1..BOUND

template <
    typename Signature$if BOUND > 0 [[,]][[]]

    $for BOUND_ARG,
    [[typename P$(BOUND_ARG)]]

>
class InvokerStorage$(BOUND) : public InvokerStorageBase
{
public:
    typedef InvokerStorage$(BOUND) StorageType;
    typedef FunctionTraits<Signature> TargetTraits;
    typedef Invoker$(BOUND)<StorageType, typename TargetTraits::NormalizedSignature> Invoker;
    typedef typename TargetTraits::IsMethod IsMethod;

$for BOUND_ARG [[
$if BOUND_ARG == 1 [[

    // For methods, we need to be careful for parameter 1, the this pointer of the method.
    // We skip the scoped_refptr check because the binder itself takes care of this.
    STATIC_ASSERT(IsMethod::Value ||
                 !internal::IsRefCountedType<P$(BOUND_ARG)>::Value,
                 "p$(BOUND_ARG) is refcounted type, should be passed by scoped_refptr");

    // We also disallow binding of an array as the method's target object.
    STATIC_ASSERT(!IsMethod::Value || !TypeTraits::IsArray<P$(BOUND_ARG)>::Value,
                 "first bound argument to method cannot be array");
]] $else [[

    STATIC_ASSERT(!internal::IsRefCountedType<P$(BOUND_ARG)>::Value,
                 "p$(BOUND_ARG) is refcounted type, should be passed by scoped_refptr");
]]  $$ $if BOUND_ARG
]]  $$ $for BOUND_ARG


    InvokerStorage$(BOUND)(const Signature& f
$if BOUND > 0 [[, ]]
$for BOUND_ARG , [[const P$(BOUND_ARG)& p$(BOUND_ARG)]])
        : function(f)[[]]
$if BOUND == 0 [[
    {

]] $else [[
, $for BOUND_ARG , [[m_p$(BOUND_ARG)(static_cast<typename ParamTraits<P$(BOUND_ARG)>::StorageType>(p$(BOUND_ARG)))]]
    {
        MaybeRefCount<IsMethod, P1>::AddRef(m_p1);

]]
    }

    virtual ~InvokerStorage$(BOUND)()
    {
$if BOUND > 0 [[

        MaybeRefCount<IsMethod, P1>::Release(m_p1);

]]
    }

    Signature function;

$for BOUND_ARG [[
    typename ParamTraits<P$(BOUND_ARG)>::StorageType m_p$(BOUND_ARG);

]]
};

]]  $$ for BOUND

}  // namespace internal
}  // namespace base


#endif // COMMON_BASE_FUNCTION_INVOKER_STORAGE_HPP
