#!/usr/bin/env python
#
# Copyright 2011 Tencent Inc.
#
# Authors: Huan Yu <huanyu@tencent.com>
#          Feng Chen <phongchen@tencent.com>
#          Yi Wang <yiwang@tencent.com>
#
# Blade is a software building system built upon SCons, but restricts
# the generality and flexibility of SCons to prevent unnecessary
# error-prone complexity.  With Blade, users wrote a BUILD file and
# put it in each of the source directory.  In each BUILD file, there
# could be one or more build rules, each has a TARGET NAME, source
# files and dependent targets.  Blade suports the following types of
# build rules:
#
#    cc_library        -- build a library from C++ source
#    cc_binary         -- build an executable binary from C++ source
#    cc_test           -- build a unittest binary from C++ source
#    proto_library     -- build a library from Protobuf source
#    lex_yacc_library  -- build a library from lex/yacc source
#    gen_rule          -- used to specify a general building rule
#
# A target may depend on other target(s), where the dependency is
# transitive.  A dependent target is referred by a TARGET ID, which
# has either of the following forms:
#
#   //<source_dir>:<target_name> -- target defined in <source_dir>/BUILD
#   :<target_name>               -- target defined in the current BUILD file
#   #<target_name>               -- target is a system library, e.g., pthread
#
# where <source_dir> is an absolute path rooted at the source tree and
# specifying where the BUILD file locates, <target_name> specifies a
# target in the BUILD file, and '//' denotes the root of the source tree.
#
# Users invoke Blade from the command line to build (or clean, or
# test) one or more rule/targets.  In the command line, a target id
# is specified in either of the following forms:
#
#   <path>:<target_name> -- to build target defined in <path>/BUILD
#   <path>               -- to build all targets defined in <path>/BUILD
#   <path>/...           -- to build all targets in all BUILD files in
#                           <path> and its desendant directories.
#
# Note that <path> in command line targets is an operating system
# path, which might be a relative path, but <source_dir> in a BUILD
# referring to a dependent target must be an absolute path, rooted at
# '//'.
#
# For example, the following command line
#
#    blade base mapreduce_lite/... parallel_svm:perf_test
#
# builds all targets in base/BUILD, all targets in all BUILDs under
# directory mapreduce_lite, and the target perf_test defined in
# parallel_svm/BUILD

from optparse import OptionParser
import glob
import os.path
import platform
import signal
import string
import shutil
import subprocess
import sys
import time
import traceback


IGNORE_IF_FAIL = 0
WARN_IF_FAIL = 1
ABORT_IF_FAIL = 2


# The directory which changes during the runtime of blade, and
# contains BUILD file under current focus.
current_source_dir = "."

# Given some targets specified in the command line, Blade will load
# BUILD files containing these command line targets; global target
# functions, i.e., cc_libarary, cc_binary and etc, in these BUILD
# files will register targets into target_database, which then becomes
# the input to dependency analyzer and SCons rules generator.  It is
# notable that not all targets in target_database are dependencies of
# command line targets.
target_database = {}

# The map used by build rules to ensure that a source file occurres in
# exactly one rule/target.
src_target_map = {}

#------------------------------------------------------------------------------
# >>>>>>               Utilities invoked by BUILD Rules                  <<<<<<
#------------------------------------------------------------------------------

# Since Python 2.5, there is a built-in function named ``any''.  Since
# Blade might be executed by Python 2.4 and earlier versions, we
# define our own _any.
def _any(iterable):
    for element in iterable:
        if element:
            return True
    return False


def _is_glob_pattern(str):
    chars = "*?![]"
    return _any([i in str for i in chars])


def _glob(patterns):
    old_pwd = os.getcwd()
    result = []
    os.chdir(current_source_dir)
    for pattern in patterns:
        if _is_glob_pattern(pattern):
            files = glob.glob(pattern)
            if not files:
                raise Exception, 'Pattern %s not found' % (pattern)
            result += files
        else:
            result.append(pattern)
    os.chdir(old_pwd)
    return result


def _error_exit(msg, code = 1):
    msg = "Blade: " + msg
    if sys.stderr.isatty():
       msg = '\033[1;31m' + msg + '\033[0m'
    print >>sys.stderr, msg
    sys.exit(code)


def _check_deps(name, deps):
    for dep in deps:
        if not (dep.startswith(':') or dep.startswith('#') or
            dep.startswith('//')):
            _error_exit('%s/%s: Invalid dep in %s.' % (current_source_dir, name, dep))
        if dep.count(':') > 1:
            _error_exit('%s/%s: Invalid dep %s, missing \',\' between 2 deps?' %
                    (current_source_dir, name, dep))


def _general_target(name, srcs = [], deps = [], target_type = ''):
    srcs = _glob(srcs)
    _check_deps(name, deps)
    key = (current_source_dir, name)
    target_database[key] = {'type' : target_type,
                           'srcs' : srcs,
                           'deps' : [],
                           'path' : current_source_dir,
                           'name' : name,
                           'options' : {}
                          }
    for s in srcs:
        if '..' in s or s.startswith('/'):
            raise Exception, (
                'Invalid source file path: %s. '
                'can only be reletive path, and must in current directory or '
                'subdirectorys') % s

        src_key = os.path.normpath('%s/%s' % (current_source_dir, s))
        src_value = '%s:%s' % (current_source_dir, name)
        if src_key in src_target_map:
            raise Exception, 'Source %s belongs to both %s and %s' % (
                    s, src_target_map[src_key], src_value)
        src_target_map[src_key] = src_value

    for d in deps:
        if d[0] == ':':
            # Depend on library in current directory
            dkey = (os.path.normpath(current_source_dir), d[1:])
        elif d.startswith('//'):
            # Depend on library in remote directory
            if not ':' in d:
                raise Exception, 'Wrong format in %s:%s' % (current_source_dir,
                                                            name)
            (path, lib) = d[2:].rsplit(':', 1)
            dkey = (os.path.normpath(path), lib)
        elif d.startswith('#'):
            # System libaray, they don't have entry in BUILD so we need
            # to add deps manually.
            dkey = ('#', d[1:])
            target_database[dkey] = {'type' : 'system_library',
                                    'srcs' : '',
                                    'deps' : [],
                                    'path' : current_source_dir,
                                    'name' : d,
                                    'options': {}
                                }
        else:
            # Depend on library in relative subdirectory
            if not ':' in d:
                raise Exception, 'Wrong format in %s:%s' % (current_source_dir,
                                                            name)
            (path, lib) = d.rsplit(':', 1)
            if '..' in path:
                raise Exception, "Don't use '..' in path"
            dkey = (os.path.normpath('%s/%s' %
                                     (current_source_dir, path)), lib)

        if dkey not in target_database[key]['deps']:
            target_database[key]['deps'].append(dkey)


def _var_to_list(var):
    if isinstance(var, list):
        return var
    return [var]


def _cc_target(name,
               srcs = [],
               deps = [],
               extra_cppflags = [],
               target_type = ''):
    srcs = _var_to_list(srcs)
    deps = _var_to_list(deps)
    extra_cppflags = _var_to_list(extra_cppflags)
    _general_target(name, srcs, deps, target_type)
    key = (current_source_dir, name)
    target_database[key]['options']['extra_cppflags'] = extra_cppflags


#------------------------------------------------------------------------------
# >>>>>>                         Build Rules                             <<<<<<
#------------------------------------------------------------------------------

def cc_library(name, srcs = [], deps = [],
               pre_build = 0, link_all_symbols = 0, extra_cppflags = [],
               **kwargs):
    _cc_target(name, srcs, deps, extra_cppflags, 'cc_library')
    key = (current_source_dir, name)
    if pre_build == 1:
        target_database[key]['type'] = 'pre_build_cc_library'
        target_database[key]['srcs'] = []

    target_database[key]['options']['link_all_symbols'] = link_all_symbols


def cc_test(name,
            srcs = [],
            deps = [],
            testdata = [],
            extra_cppflags = [],
            **kwargs):
    testdata = _var_to_list(testdata)
    _cc_target(name, srcs, deps, extra_cppflags, 'cc_test')

    key = (current_source_dir, name)
    target_database[key]['options']['testdata'] = testdata

    # Hardcode deps rule to thirdparty gtest main lib.
    dkey = ('thirdparty/gtest', 'gtest_main')
    if dkey not in target_database[key]['deps']:
        target_database[key]['deps'].append(dkey)

    dkey = ('thirdparty/gtest', 'gtest')
    if dkey not in target_database[key]['deps']:
        target_database[key]['deps'].append(dkey)


def cc_binary(name,
              srcs = [],
              deps = [],
              dynamic_link = 0,
              extra_cppflags = [],
              **kwargs):
    _cc_target(name, srcs, deps, extra_cppflags, 'cc_binary')
    key = (current_source_dir, name)
    if dynamic_link == 1:
        target_database[key]['type'] = 'dynamic_cc_binary'


def proto_library(name, srcs = [], deps = [], **kwargs):
    srcs = _var_to_list(srcs)
    deps = _var_to_list(deps)
    _general_target(name, srcs, deps, 'proto_library')

    # Hardcode deps rule to thirdparty protobuf lib.
    dkey = ('thirdparty/protobuf', 'protobuf')
    key = (current_source_dir, name)
    if dkey not in target_database[key]['deps']:
        target_database[key]['deps'].append(dkey)


def lex_yacc_library(name, srcs = [], deps = [], **kwargs):
    if len(srcs) != 2:
        raise Exception, ("'srcs' for lex_yacc_library should "
                          "be a pair of (lex_source, yacc_source)")
    deps = _var_to_list(deps)
    _general_target(name, srcs, deps, 'lex_yacc_library')


def gen_rule(name, srcs = [], outs = [], deps = [], cmd = "", **kwargs):
    srcs = _var_to_list(srcs)
    deps = _var_to_list(deps)
    outs = _var_to_list(outs)
    _general_target(name, srcs, deps, 'gen_rule')
    key = (current_source_dir, name)
    target_database[key]['outs'] = outs
    target_database[key]['cmd'] = cmd


#------------------------------------------------------------------------------
# >>>>>>              Rules/Targets Dependency Expander                  <<<<<<
#------------------------------------------------------------------------------

# Given the map of related targets, i.e., the subset of target_database
# that are dependencies of those targets speicifed in Blade command
# line, this utility class expands the 'deps' property of each target
# to be all direct and indirect dependencies of that target.
class DependenciesExpander:
    def __init__(self, targets):
        self.targets = targets


    def expand_deps(self):
        for target_id in self.targets.keys():
            self.targets[target_id]['deps'] = self._find_all_deps(target_id)
            # Handle the special case: dependencies of a dynamic_cc_binary
            # must be built as dynamic libraries.
            if self.targets[target_id]['type'] == 'dynamic_cc_binary':
                for dep in self.targets[target_id]['deps']:
                    self.targets[dep]['options']['build_dynamic'] = 1


    # Return all targets depended by target_id directly and/or indirectly.
    # We need the parameter root_target_id to check loopy dependency.
    def _find_all_deps(self, target_id, root_target_id = None):
        if root_target_id == None:
            root_target_id = target_id
        new_deps_list = []
        for d in self.targets[target_id]['deps']:
            if d == root_target_id:
                print "loop dependency of %" % ':'.join(root_target_id)
            new_deps_piece = [d]
            if d not in self.targets:
                _error_exit('Target %s:%s depends on %s:%s, '
                            'but it is missing, exit...' % (target_id[0],
                                                            target_id[1],
                                                            d[0],
                                                            d[1]))
            new_deps_piece += self._find_all_deps(d, root_target_id)
            # Append new_deps_piece to new_deps_list, be aware of
            # de-duplication:
            for nd in new_deps_piece:
                if nd in new_deps_list:
                    new_deps_list.remove(nd)
                new_deps_list.append(nd)
        return new_deps_list


    def get_targets(self):
        return self.targets


#------------------------------------------------------------------------------
# >>>>>>                   SCons Rules Generator                         <<<<<<
#------------------------------------------------------------------------------

class SconsRulesGenerator:
    def __init__(self, scons_path, targets, options):
        self.targets = targets
        self.objects = {}
        self.scons_file = open(scons_path, 'w')
        self.build_dir = "build%s_%s" % (options.m, options.profile)
        self.options = options
        self.gcc_version = self._get_gcc_version("gcc")

    def _output(self, content):
        print >>self.scons_file, content

    @staticmethod
    def _get_gcc_version(compiler):
        p = subprocess.Popen(
            compiler + " --version",
            env={},
            stderr=subprocess.PIPE,
            stdout=subprocess.PIPE,
            shell=True,
            universal_newlines=True)
        (stdout, stderr) = p.communicate()
        if p.returncode == 0:
            version_line = stdout.splitlines(True)[0]
            version = version_line.split()[2]
            return version
        return ""

    def _topological_sort(self, pairlist):
        numpreds = {}   # elt -> # of predecessors
        successors = {} # elt -> list of successors
        for second, options in pairlist.items():
            if not numpreds.has_key(second):
                numpreds[second] = 0
            deps = options['deps']
            for first in deps:
                # make sure every elt is a key in numpreds
                if not numpreds.has_key(first):
                    numpreds[first] = 0

                # since first < second, second gains a pred ...
                numpreds[second] = numpreds[second] + 1

                # ... and first gains a succ
                if successors.has_key(first):
                    successors[first].append(second)
                else:
                    successors[first] = [second]

        # suck up everything without a predecessor
        answer = filter(lambda x, numpreds=numpreds: numpreds[x] == 0,
                        numpreds.keys())

        # for everything in answer, knock down the pred count on
        # its successors; note that answer grows *in* the loop
        for x in answer:
            assert numpreds[x] == 0
            del numpreds[x]
            if successors.has_key(x):
                for y in successors[x]:
                    numpreds[y] = numpreds[y] - 1
                    if numpreds[y] == 0:
                        answer.append(y)

        return answer


    def _regular_variable_name(self, name):
        s = name
        for i in [',', '-', '/', '.', '+']:
            s = s.replace(i, '_')
        return s


    def _generate_variable_name(self, path, name, suffix = ""):
        suffix_str = ""
        if suffix:
            suffix_str = "_suFFix_%s" % suffix
        return "v_%s_mAgIc_%s%s" % (self._regular_variable_name(path),
                                    self._regular_variable_name(name),
                                    suffix_str)


    def _file_path(self, path, file):
        return "%s/%s/%s" % (self.build_dir, path, file)

    def _srcs_list(self, path, srcs):
        return ','.join(["'%s'" % self._file_path(path, src) for src in srcs])


    def _proto_gen_files(self, path, src):
        proto_name = src[:-6]
        return (self._file_path(path, '%s.pb.cc' % proto_name),
                self._file_path(path, '%s.pb.h' % proto_name))


    def _proto_src_file(self, path, src):
        return '%s/%s' % (path, src)


    def _env_name(self, target):
        return "env_%s" % self._generate_variable_name(target['path'],
                                                       target['name'])


    def _objs_name(self, target):
        return "objs_%s" % self._generate_variable_name(target['path'],
                                                        target['name'])


    # TODO(phongchen) more reliable way
    def _dep_is_library(self, dep):
        return 'library' in self.targets[dep].get('type')


    def _static_deps_list(self, deps):
        lib_list = []
        link_all_symbols_lib_list = []
        for lib in deps:
            # lib is (path, libname) pair.
            if not lib:
                continue

            if not self._dep_is_library(lib):
                continue

            # system lib
            if lib[0] == "#":
                lib_name = "'%s'" % lib[1]
                lib_path = lib[1]
            else:
                lib_name = self._generate_variable_name(lib[0], lib[1])
                lib_path = self._file_path(lib[0], 'lib%s.a' % lib[1])

            if self.targets[lib].get('options', {}).get('link_all_symbols', 0):
                link_all_symbols_lib_list.append((lib_path, lib_name))
            else:
                lib_list.append(lib_name)

        return (link_all_symbols_lib_list, lib_list)


    def _dynamic_deps_list(self, deps):
        lib_list = []
        for lib in deps:
            # lib is (path, libname) pair.
            if not lib:
                continue

            if not self._dep_is_library(lib):
                continue

            if (self.targets[lib]['type'] == 'cc_library' and
                not self.targets[lib]['srcs']):
                continue
            # system lib
            if lib[0] == "#":
                lib_name = "'%s'" % lib[1]
            else:
                lib_name = self._generate_variable_name(lib[0],
                                                        lib[1],
                                                        "dynamic")

            lib_list.append(lib_name)

        return lib_list


    def _pre_build_cc_library_build_path(self, path, name, dynamic = 0):
        if not dynamic:
            return "%s" % os.path.join(
                self.build_dir,
                path,
                'lib%s.a' % name)
        else:
            return "%s" % os.path.join(
                self.build_dir,
                path,
                'lib%s.so' % name)


    def _pre_build_cc_library_src_path(self, path, name, dynamic = 0):
        if not dynamic:
            return "%s" % os.path.join(
                path,
                'lib%s_%s' % (self.options.m, self.options.profile),
                'lib%s.a' % name)
        else:
            return "%s" % os.path.join(
                path,
                'lib%s_%s' % (self.options.m, self.options.profile),
                'lib%s.so' % name)


    def _env_rules(self):
        for key, target in self.targets.items():
            if target['type'] == 'system_library':
                continue
            env_name = self._env_name(target)
            self._output("%s = env.Clone()" % env_name)

    def _objects_rules(self):
        target_types = ["cc_library",
                        "cc_binary",
                        "dynamic_cc_binary",
                        "cc_test"]

        for key, target in self.targets.items():
            path = target['path']
            objs_name = self._objs_name(target)

            if target['type'] not in target_types:
                continue

            env_name = self._env_name(target)
            extra_cppflags = target.get('options', {}).get('extra_cppflags',
                                                           [])
            if extra_cppflags:
                self._output("%s.Append(CPPFLAGS = %s)" % (
                    env_name, extra_cppflags))
            objs = []
            for src in target['srcs']:
                src_name = self._generate_variable_name(path, src)
                if src_name not in self.objects:
                    self.objects[src_name] = (
                        "%s_object" % self._generate_variable_name(path, src))
                    self._output(
                        "%s = %s.SharedObject(target = '%s' + env['OBJSUFFIX']"
                        ", source = '%s')" % (self.objects[src_name],
                                              env_name,
                                              self._file_path(path, src),
                                              self._file_path(path, src)))
                objs.append(self.objects[src_name])
            self._output("%s = [%s]" % (objs_name, ','.join(objs)))


    def _cc_binary_rules(self, target):
        env_name = self._env_name(target)

        (link_all_symbols_lib_list, lib_list) = self._static_deps_list(
            target['deps'])
        lib_str = ""
        if lib_list:
            lib_str = 'LIBS=[%s]' % ','.join(lib_list)
        if link_all_symbols_lib_list:
            whole_link_flags = ["-Wl,--whole-archive"]
            for i in link_all_symbols_lib_list:
                whole_link_flags.append(i[0])
            whole_link_flags.append('-Wl,--no-whole-archive')
            self._output(
                    '%s.Append(LINKFLAGS=%s)' % (env_name, whole_link_flags))

        self._output("%s = %s.Program('%s', %s, %s)" % (
            self._generate_variable_name(target['path'], target['name']),
            env_name,
            self._file_path(target['path'], target['name']),
            self._objs_name(target),
            lib_str))

        for i in link_all_symbols_lib_list:
            self._output("%s.Depends(%s, %s)" % (
                env_name,
                self._generate_variable_name(target['path'],
                                             target['name']),
                i[1]))

        self._output('%s.Append(LINKFLAGS=str(version_obj[0]))' % env_name)
        self._output("%s.Requires(%s, version_obj)" % (
            env_name,
            self._generate_variable_name(target['path'], target['name'])))


    def _cc_test_rules(self, target):
        self._cc_binary_rules(target)

    def _dynamic_cc_binary_rules(self, target):
        env_name = self._env_name(target)

        lib_list = self._dynamic_deps_list(target['deps'])
        lib_str = ""
        if lib_list:
            lib_str = 'LIBS=[%s]' % ','.join(lib_list)

        self._output("%s = %s.Program('%s', %s, %s)" % (
            self._generate_variable_name(target['path'], target['name']),
            env_name,
            self._file_path(target['path'], target['name']),
            self._objs_name(target),
            lib_str))

    def _dynamic_cc_library_rules(self, target):
        lib_list = self._dynamic_deps_list(target['deps'])
        lib_str = ""
        if lib_list:
             lib_str = 'LIBS=[%s]' % ','.join(lib_list)
        env_name = self._env_name(target)
        if target['srcs'] or target['deps']:
            self._output('%s.Append(LINKFLAGS=["-Xlinker", "--no-undefined"])'
                % env_name)
            self._output("%s = %s.SharedLibrary('%s', %s, %s)" % (
                self._generate_variable_name(target['path'],
                                             target['name'],
                                             'dynamic'),
                env_name,
                self._file_path(target['path'], target['name']),
                self._objs_name(target),
                lib_str))

    def _cc_library_rules(self, target):
        env_name = self._env_name(target)

        self._output("%s = %s.Library('%s', %s)" % (
            self._generate_variable_name(target['path'], target['name']),
            env_name,
            self._file_path(target['path'], target['name']),
            self._objs_name(target)))
        if (self.options.generate_dynamic or
            target.get('options', {}).get('build_dynamic', 0)):
            self._dynamic_cc_library_rules(target)

    def _proto_library_rules(self, target):
        obj_names = []
        for src in target['srcs']:
            (proto_src, proto_hdr) = self._proto_gen_files(target['path'], src)

            self._output("env.Proto(['%s', '%s'], '%s')" % (
                proto_src,
                proto_hdr,
                self._proto_src_file(target['path'], src)))
            obj_name = "%s_object" % self._generate_variable_name(
                target['path'], src)
            obj_names.append(obj_name)
            self._output(
                "%s = env.SharedObject(target = '%s' + env['OBJSUFFIX'], "
                "source = '%s')" % (obj_name,
                                    proto_src,
                                    proto_src))

        self._output("%s = [%s]" % (self._objs_name(target),
                                    ','.join(obj_names)))
        self._output("%s = env.Library('%s', %s)" % (
            self._generate_variable_name(target['path'], target['name']),
            self._file_path(target['path'], target['name']),
            self._objs_name(target)))

        if (self.options.generate_dynamic or
            target.get('options', {}).get('build_dynamic', 0)):
            self._dynamic_cc_library_rules(target)

    def _lex_yacc_library_rules(self, target):
        lex_source_file = self._file_path(target['path'], target['srcs'][0])
        lex_cc_file = '%s.cc' % lex_source_file
        self._output(
            "lex_%s = env.CXXFile(target='%s', source='%s');" % (
            self._generate_variable_name(target['path'], target['name']),
            lex_cc_file, lex_source_file))
        yacc_source_file = self._file_path(target['path'], target['srcs'][1])
        yacc_cc_file = '%s.cc' % yacc_source_file
        yacc_hh_file = '%s.hh' % yacc_source_file
        self._output(
            "yacc_%s = env.Yacc(target=['%s', '%s'], source='%s');" % (
            self._generate_variable_name(target['path'], target['name']),
            yacc_cc_file, yacc_hh_file, yacc_source_file))
        self._output("env.Depends(lex_%s, yacc_%s)" % (
            self._generate_variable_name(target['path'], target['name']),
            self._generate_variable_name(target['path'], target['name'])))


        self._output(
            "%s = ['%s', '%s']" % (self._objs_name(target),
                                   lex_cc_file,
                                   yacc_cc_file))
        self._output("%s = env.Library('%s', %s)" % (
            self._generate_variable_name(target['path'], target['name']),
            self._file_path(target['path'], target['name']),
            self._objs_name(target)))

        if (self.options.generate_dynamic or
            target.get('options', {}).get('build_dynamic', 0)):
            self._dynamic_cc_library_rules(target)

    def _pre_build_cc_library_rules(self, target):
        var_name = self._generate_variable_name(target['path'], target['name'])
        self._output(
            'Command("%s", "%s", Copy("$TARGET", "$SOURCE"))' % (
                self._pre_build_cc_library_build_path(target['path'],
                                                      target['name']),
                self._pre_build_cc_library_src_path(target['path'],
                                                    target['name'])))
        self._output("%s = env.File('%s')" % (
            var_name,
            self._pre_build_cc_library_build_path(target['path'],
                                                   target['name'])))
        if (self.options.generate_dynamic or
            target.get('options', {}).get('build_dynamic', 0)):
            self._output(
                'Command("%s", "%s", Copy("$TARGET", "$SOURCE"))' % (
                    self._pre_build_cc_library_build_path(target['path'],
                                                          target['name'],
                                                          dynamic = 1),
                    self._pre_build_cc_library_src_path(target['path'],
                                                        target['name'],
                                                        dynamic = 1)))
            var_name = self._generate_variable_name(target['path'],
                                                    target['name'],
                                                    "dynamic")
            self._output("%s = env.File('%s')" % (
                var_name,
                self._pre_build_cc_library_build_path(target['path'],
                                                      target['name'],
                                                      1)))

    def _gen_rule_rules(self, target):
        var_name = self._generate_variable_name(target['path'], target['name'])
        env_name = self._env_name(target)
        self._output("%s = env.Clone()" % env_name)

        srcs_str = ""
        if not target['srcs']:
            srcs_str = 'time_value'
        else:
            srcs_str = self._srcs_list(target['path'], target['srcs'])
        cmd = target['cmd']
        cmd = cmd.replace("$SRCS", '$SOURCES')
        cmd = cmd.replace("$OUTS", '$TARGETS')
        cmd = cmd.replace("$FIRST_SRC", '$SOURCE')
        cmd = cmd.replace("$FIRST_OUT", '$TARGET')
        cmd = cmd.replace("$BUILD_DIR", self.build_dir)
        self._output('%s = %s.Command([%s], [%s], "%s")' % (
            var_name,
            env_name,
            self._srcs_list(target['path'], target['outs']),
            srcs_str,
            cmd))
        for i in target['deps']:
            dep_target = self.targets[i]
            if dep_target['type'] == 'system_library':
                continue
            dep_var_name = self._generate_variable_name(
                dep_target['path'], dep_target['name'])
            self._output("%s.Depends(%s, %s)" % (env_name,
                                                 var_name,
                                                 dep_var_name))

    def output(self):
        try:
            os.remove("blade-bin")
        except os.error:
            pass
        os.symlink(os.path.abspath(self.build_dir), "blade-bin")
        self._output(
"""
import os
import subprocess
import sys
import signal
import time
import socket

SetOption('implicit_cache', 1)

""")

        self._output((
"""if not os.path.exists('%s'):
    os.mkdir('%s')""") % (self.build_dir, self.build_dir))

        version_cpp_template = string.Template("""
version_cpp = open('$filename', 'w')
print >>version_cpp, 'extern "C" {'
print >>version_cpp, 'namespace binary_version {'
print >>version_cpp, 'extern const char kBuildTime[] = "%s";' % time.asctime()
print >>version_cpp, 'extern const char kBuilderName[] = "%s";' % os.getenv('USER')
print >>version_cpp, (
    'extern const char kHostName[] = "%s";' % socket.gethostname())
print >>version_cpp, 'extern const char kCompiler[] = "$compiler";'
print >>version_cpp, '}'
print >>version_cpp, '}'
version_cpp.close()
env_version = Environment(ENV = os.environ)
env_version.Append(SHCXXCOMSTR = 'Version information updated')
env_version.Append(CPPFLAGS = '-m$m')
version_obj = env_version.SharedObject('$filename')
""")
        self._output(version_cpp_template.substitute(
            filename = "%s/version.cpp" % self.build_dir,
            compiler = "GCC %s" % self.gcc_version,
            m = self.options.m))

        self._output("VariantDir('%s', '.', duplicate=0)" % self.build_dir)
        cppflags = ["-m%s" % self.options.m]
        cppflags += ["-Wall", "-Wextra", "-Wformat=2", "-Wno-unused-parameter",
                     "-Wno-missing-field-initializers",
                     "-Wmissing-include-dirs", "-Wfloat-equal",
                     "-Wpointer-arith", "-Wwrite-strings"]

        cflags = ["-Werror-implicit-function-declaration"]
        cxxflags = ["-Woverloaded-virtual",
                    "-Wnon-virtual-dtor",
                    "-Wno-invalid-offsetof"]
        # all known gcc versions(m.m.p format) are saft to compare as string
        if self.gcc_version > "4.1.2":
            cppflags += [
                "-Werror=char-subscripts",
                "-Werror=format",
                "-Werror=return-type",
                "-Werror=overflow",
                "-Werror=parentheses",
                "-Werror=reorder",
                "-Werror=type-limits",
                "-Werror=unused-variable"
            ]
            cxxflags += [
                "-Werror=non-virtual-dtor"
            ]

        linkflags = ["-m%s" % self.options.m]
        if self.options.profile == 'debug':
            cppflags += ["-ggdb3", "-fstack-protector"]
        elif self.options.profile == 'release':
            cppflags += ["-g", "-O2", "-DNDEBUG"]
        cppflags += ["-D_FILE_OFFSET_BITS=64"]

        if self.options.gprof:
            cppflags.append('-pg')
            linkflags.append('-pg')

        if self.options.gcov:
            cppflags.append('--coverage')
            linkflags.append('--coverage')

        self._output("os.environ['LC_ALL'] = 'C'")
        self._output("""
env = Environment(ENV = os.environ, CPPPATH=['thirdparty',
                                             '%s'],
                  CPPFLAGS = %s, CFLAGS = %s, CXXFLAGS = %s, LINKFLAGS = %s)
""" % (self.build_dir, cppflags, cflags, cxxflags, linkflags))

        if self.options.cache_dir:
            self._output("CacheDir('%s')" % self.options.cache_dir)
            self._output("print('Blade: Using cache directory %s')" %
                    (self.options.cache_dir))

        self._output(
"""
env.Decider('MD5-timestamp')
colors = {}
colors['red']    = '\033[1;31m'
colors['green']  = '\033[1;32m'
colors['yellow'] = '\033[1;33m'
colors['blue']   = '\033[1;34m'
colors['purple'] = '\033[1;35m'
colors['cyan']   = '\033[1;36m'
colors['white']  = '\033[1;37m'
colors['gray']   = '\033[1;38m'
colors['end']    = '\033[0m'
""")

        if not self.options.color:
            self._output(
"""
for key, value in colors.iteritems():
    colors[key] = ''
""")

        self._output(
"""
def error_colorize(message):
    colored_message = ""
    errors = [": error:", ": undefined reference to"]
    warnings = [": warning:", ": note: "]
    for t in message.splitlines(True):
        color = 'cyan'
        for w in warnings:
            if w in t:
                color = 'yellow'
                break
        for w in errors:
            if w in t:
                color = 'red'
                break
        colored_message += "%s%s%s" % (colors[color], t, colors['end'])
    return colored_message

def echospawn( sh, escape, cmd, args, env ):
    # convert env from unicode strings
    asciienv = {}
    for key, value in env.iteritems():
        asciienv[key] = str(value)

    cmdline = ' '.join(args)
    p = subprocess.Popen(
        cmdline,
        env=asciienv,
        stderr=subprocess.PIPE,
        stdout=subprocess.PIPE,
        shell=True,
        universal_newlines=True)
    (stdout, stderr) = p.communicate()

    if p.returncode:
        if p.returncode != -signal.SIGINT:
            print "%s%s%s" % (colors['red'], cmdline, colors['end'])
            sys.stdout.write(error_colorize(stdout))
            sys.stderr.write(error_colorize(stderr))
    else:
        if stderr:
            print "%s%s%s" % (colors['yellow'], cmdline, colors['end'])
            sys.stderr.write(error_colorize(stderr))
            sys.stdout.write(error_colorize(stdout))
        else:
            sys.stdout.write(stdout)

    return p.returncode

env['SPAWN'] = echospawn
""")
        if not self.options.verbose:
            self._output(
"""
compile_source_message = '%sCompiling %s==>%s $SOURCE%s' % \
    (colors['cyan'], colors['purple'], colors['cyan'], colors['end'])

compile_shared_source_message = '%sCompiling %s==>%s $SOURCE%s' % \
    (colors['cyan'], colors['purple'], colors['cyan'], colors['end'])

link_program_message = '%sLinking Program %s==>%s $TARGET%s' % \
    (colors['green'], colors['purple'], colors['green'], colors['end'])

link_library_message = '%sCreating Static Library %s==> %s$TARGET%s' % \
    (colors['green'], colors['purple'], colors['green'], colors['end'])

ranlib_library_message = '%sRanlib Library %s==> %s$TARGET%s' % \
    (colors['green'], colors['purple'], colors['green'], colors['end']) \

link_shared_library_message = '%sLinking Shared Library %s==> %s$TARGET%s' % \
    (colors['green'], colors['purple'], colors['green'], colors['end'])

env.Append(
  CXXCOMSTR = compile_source_message,
  CCCOMSTR = compile_source_message,
  SHCCCOMSTR = compile_shared_source_message,
  SHCXXCOMSTR = compile_shared_source_message,
  ARCOMSTR = link_library_message,
  RANLIBCOMSTR = ranlib_library_message,
  SHLINKCOMSTR = link_shared_library_message,
  LINKCOMSTR = link_program_message,
)

""")

        self._output("time_value = Value('%s')" %  time.asctime())
        self._output(
            "proto_bld = Builder(action = 'protoc --proto_path=. "
            "--proto_path=thirdparty --cpp_out=%s -I=`dirname $SOURCE` "
            "$SOURCE')" % self.build_dir)

        self._output("env.Append(BUILDERS = {'Proto' : proto_bld})")

        self._output(
            "yacc_bld = Builder(action = 'bison -d -o $TARGET $SOURCE')")
        self._output("env.Append(BUILDERS = {'Yacc' : yacc_bld})")

        self._env_rules()
        self._objects_rules()
        for k in self._topological_sort(self.targets):
            target = self.targets[k]
            var_name = self._generate_variable_name(target['path'],
                                                    target['name'])
            if target['type'] == 'cc_binary':
                self._cc_binary_rules(target)
            elif target['type'] == 'cc_test':
                self._cc_test_rules(target)
            elif target['type'] == 'dynamic_cc_binary':
                self._dynamic_cc_binary_rules(target)
            elif target['type'] == 'cc_library':
                self._cc_library_rules(target)
            elif target['type'] == 'pre_build_cc_library':
                self._pre_build_cc_library_rules(target)
            elif target['type'] == 'proto_library':
                self._proto_library_rules(target)
            elif target['type'] == 'lex_yacc_library':
                self._lex_yacc_library_rules(target)
            elif target['type'] == 'gen_rule':
                self._gen_rule_rules(target)

        self.scons_file.close()

#------------------------------------------------------------------------------
# >>>>>>                  Commandline Options Parser                     <<<<<<
#------------------------------------------------------------------------------

class CmdOptions:
    def __init__(self):
        (self.options, self.args) = self._cmd_parse()
        if (self.options.profile != 'debug' and
            self.options.profile != 'release'):
            _error_exit("--profile must be 'debug' or 'release'.")

        if self.options.m is None:
            self.options.m = self._arch_bits()
        else:
            if not (self.options.m == "32" or self.options.m == "64"):
                _error_exit("--m must be '32' or '64'")

            # TODO(phongchen): cross compile checking
            if self.options.m == "64" and platform.machine() != "x86_64":
                _error_exit("Sorry, 64-bit environment is required for "
                            "building 64-bit targets.")

        if self.options.color == "yes":
            self.options.color = True;
        elif self.options.color == "no":
            self.options.color = False;
        elif self.options.color == "auto" or  self.options.color is None:
            self.options.color = sys.stdout.isatty()
        else:
            _error_exit("--color can only be yes, no or auto.")

        if self.options.cache_dir is None:
            try:
                self.options.cache_dir = os.environ['BLADE_CACHE_DIR']
            except:
                pass
        if self.options.cache_dir:
            self.options.cache_dir = os.path.expanduser(self.options.cache_dir)

    def _cmd_parse(self):
        cmd_parser = OptionParser('%prog [options] target1[ target2...]')

        # Build profiles
        cmd_parser.add_option("-m",
                              dest = "m",
                              help = ("Generate code for a 32-bit(-m32) or "
                                      "64-bit(-m64) environment, "
                                      "default is autodetect."))
        cmd_parser.add_option("-p",
                              "--profile",
                              dest = "profile",
                              default = "release",
                              help = ("Build profile: debug or release, "
                                      "default is release."))

        # Actions
        cmd_parser.add_option(
            "-c", "--clean", dest = "clean",
            action = "store_true", default = False,
            help = "Clean up by removing all target files for which "
                   "a construction command is specified.")
        cmd_parser.add_option(
            "--generate_scons_only", dest = "scons_only",
            action = "store_true", default = False,
            help = "Generate scons script for debug purpose.")
        cmd_parser.add_option(
            "-t", "--test", dest = "test",
            action = "store_true", default = False,
            help = "Run all testing targets after successful build.")

        cmd_parser.add_option(
            "--testargs", dest = "testargs", type = "string",
            help = "Command line arguments to be passed to tests.")

        # Options
        cmd_parser.add_option(
            "-j", "--jobs", dest = "jobs", type = "int", default = 1,
            help = ("Specifies the number of jobs (commands) to "
                    "run simultaneously."))
        cmd_parser.add_option(
            "--cache-dir", dest = "cache_dir", type = "string",
            help = "Specifies location of shared cache directory.")
        cmd_parser.add_option(
            "--verbose", dest = "verbose", action = "store_true",
            default = False, help = "Show all details.")
        cmd_parser.add_option(
            "--color", dest = "color",
            default = "auto",
            help = "Enable color: yes, no or auto, default is auto.")

        cmd_parser.add_option(
            "--generate-dynamic", dest = "generate_dynamic",
            action = "store_true", default = False,
            help = "Generate dynamic libraries.")

        cmd_parser.add_option(
            "--gprof", dest = "gprof",
            action = "store_true", default = False,
            help = "Add build options to support GNU gprof.")

        cmd_parser.add_option(
            "--gcov", dest = "gcov",
            action = "store_true", default = False,
            help = "Add build options to support GNU gcov to do coverage test.")
        return cmd_parser.parse_args()


    def _arch_bits(self):
        if 'x86_64' == platform.machine():
            return '64'
        else:
            return '32'


    def get_args(self):
        return self.args


    def get_options(self):
        return self.options

#------------------------------------------------------------------------------
# >>>>>>                         Unit Test Runner                        <<<<<<
#------------------------------------------------------------------------------

class TestRunner:
    def __init__(self, targets, options):
        self.targets = targets
        self.build_dir = "build%s_%s" % (options.m, options.profile)
        self.options = options

    def _test_executable(self, target):
        return "%s/%s/%s" % (self.build_dir, target['path'], target['name'])


    def _runfiles_dir(self, target):
        return "./%s.runfiles" % (self._test_executable(target))


    def _prepare_test_env(self, target):
        shutil.rmtree(self._runfiles_dir(target), ignore_errors = True)
        os.mkdir(self._runfiles_dir(target))
        for i in target['options']['testdata']:
            if '..' in i or i.startswith('/'):
                continue
            try:
                os.makedirs(os.path.dirname('%s/%s' % (
                    self._runfiles_dir(target), i)))
            except os.error:
                pass
            os.symlink(os.path.abspath("%s/%s" % (target['path'], i)),
                       '%s/%s' % (self._runfiles_dir(target), i))

    def run(self):
        failed_targets = []
        for target in self.targets.values():
            if not target['type'] == 'cc_test':
                continue
            self._prepare_test_env(target)
            old_pwd = os.getcwd()
            cmd = "%s --gtest_output=xml" % os.path.abspath(self._test_executable(target))
            if self.options.testargs:
                cmd = "%s %s" % (cmd, self.options.testargs)

            print "Running %s" % cmd
            sys.stdout.flush() # make sure output before scons if redirected

            os.chdir(self._runfiles_dir(target))
            p = subprocess.Popen(cmd, shell = True)
            p.wait()
            if p.returncode:
                target["test_exit_code"] = p.returncode
                failed_targets.append(target)

            os.chdir(old_pwd)

        print "============== Testing Summary ============="
        if failed_targets:
            print "Tests failed:"
            for i in failed_targets:
                print "%s/%s, exit code: %s" % (
                        i["path"], i["name"], i["test_exit_code"])
            return 1
        else:
            print "All Tests passed!"
            return 0


#------------------------------------------------------------------------------
# >>>>>>            Recursively Load and Execute BUILD Files             <<<<<<
#------------------------------------------------------------------------------

# Invoked by _load_targets.  Load and execute the BUILD
# file, which is a Python script, in source_dir.  Statements in BUILD
# depends on global variable current_source_dir, and will register build
# target/rules into global variables target_database.  If path/BUILD
# does NOT exsit, take action corresponding to action_if_fail.  The
# parameters processed_source_dirs refers to a set defined in the
# caller and used to avoid duplicated execution of BUILD files.
def _load_build_file(source_dir, action_if_fail, processed_source_dirs):
    source_dir = os.path.normpath(source_dir)
    # TODO(yiwang): the character '#' is a magic value.
    if source_dir in processed_source_dirs or source_dir == '#':
        return
    processed_source_dirs.add(source_dir)

    global current_source_dir
    old_path = current_source_dir
    current_source_dir = source_dir
    build_file = os.path.join(source_dir, 'BUILD')
    if os.path.exists(build_file):
        try:
            # The magic here is that a BUILD file is a Python script,
            # which can be loaded and executed by execfile().
            execfile(build_file)
        except SystemExit:
            _error_exit("%s: fatal error, exit..." % build_file)
        except:
            _error_exit('Parse error in %s, exit...\n%s' % (
                build_file, traceback.format_exc()))
    else:
        if action_if_fail == WARN_IF_FAIL:
            print >>sys.stderr, '%s not exist, skip...' % build_file
        elif action_if_fail == ABORT_IF_FAIL:
            _error_exit('%s not exist, exit...' % build_file)
    current_source_dir = old_path


def _find_depender(dkey):
    for key in target_database:
        if dkey in target_database[key]['deps']:
            return "//%s:%s" % (target_database[key]["path"],
                                target_database[key]["name"])
    return None


# Get the relative path of a_path by considering reference_path as the
# root directory.  For example, if
#   reference_path = "/src/paralgo"
#   a_path        = "/src/paralgo/mapreduce_lite/sorted_buffer"
# then
#   _relative_path(a_path, reference_path) = "mapreduce_lite/sorted_buffer"
#
def _relative_path(a_path, reference_path):
    if not a_path:
        raise ValueError("no path specified")

    # Count the number of segments shared by reference_path and a_path.
    reference_list = os.path.abspath(reference_path).split(os.path.sep)
    path_list  = os.path.abspath(a_path).split(os.path.sep)
    for i in range(min(len(reference_list), len(path_list))):
        # TODO(yiwang): Why use lower here?
        if reference_list[i].lower() != path_list[i].lower():
            break
        else:
            # TODO(yiwnag): Why do not move i+=1 out from the loop?
            i += 1

    rel_list = [os.path.pardir] * (len(reference_list)-i) + path_list[i:]
    if not rel_list:
        return os.path.curdir
    return os.path.join(*rel_list)


# Parse and load targets, including those specified in command line
# and their direct and indirect dependencies, by loading related BUILD
# files.  Returns a map which contains all these targets.
def _load_targets(target_ids, working_dir, blade_root_dir):
    global target_database

    # targets specified in command line
    cited_targets = set()
    # cited_targets and all its dependencies
    related_targets = {}
    # source dirs mentioned in command line
    source_dirs = []
    # to prevent duplicated loading of BUILD files
    processed_source_dirs = set()

    # Parse command line target_ids.  For those in the form of <path>:<target>,
    # record (<path>,<target>) in cited_targets; for the rest (with <path>
    # but without <target>), record <path> into paths.
    for target_id in target_ids:
        if target_id.find(':') == -1:
            source_dir, target_name = target_id, '*'
        else:
            source_dir, target_name = target_id.rsplit(':', 1)

        source_dir = _relative_path(os.path.join(working_dir, source_dir),
                                    blade_root_dir)

        if target_name != '*' and target_name != '':
            cited_targets.add((source_dir, target_name))
        elif source_dir.endswith('...'):
            source_dir = source_dir[:-3]
            if not source_dir:
                source_dir = "./"
            source_dirs.append((source_dir, WARN_IF_FAIL))
            for root, dirs, files in os.walk(source_dir):
                # Skip over subdirs starting with '.', e.g., .svn.
                dirs[:] = [d for d in dirs if not d.startswith('.')]
                for d in dirs:
                    source_dirs.append((os.path.join(root, d), IGNORE_IF_FAIL))
        else:
            source_dirs.append((source_dir, ABORT_IF_FAIL))

    # Load BUILD files in paths, and add all loaded targets into
    # cited_targets.  Together with above step, we can ensure that all
    # targets mentioned in the command line are now in cited_targetts.
    for source_dir, action_if_fail in source_dirs:
        _load_build_file(source_dir, action_if_fail, processed_source_dirs)
    for key in target_database:
        cited_targets.add(key)

    # Starting from targets specified in command line, breath-first
    # propagate to load BUILD files containing directly and indirectly
    # dependent targets.  All these targets form related_targets,
    # which is a subset of target_databased created by loading  BUILD files.
    while cited_targets:
        source_dir, target_name = cited_targets.pop()
        target_id = (source_dir, target_name)
        if target_id in related_targets:
            continue

        _load_build_file(source_dir, ABORT_IF_FAIL, processed_source_dirs)
        if target_id not in target_database:
            raise Exception, "%s: target //%s:%s does not exists" % (
                _find_depender(target_id), source_dir, target_name)

        related_targets[target_id] = target_database[target_id]
        for key in related_targets[target_id]['deps']:
            if key not in related_targets:
                cited_targets.add(key)

    return related_targets


# The blade_root_dir is the directory which is the closest upper level
# directory of the current working directory, and containing a file
# named BLADE_ROOT.
def _find_blade_root_dir(working_dir):
    blade_root_dir = working_dir
    while blade_root_dir != "/":
        if os.path.isfile(os.path.join(blade_root_dir, "BLADE_ROOT")):
            break
        os.chdir("..")
        blade_root_dir = os.getcwd()
    if blade_root_dir == "/":
        _error_exit("Can't find BLADE_ROOT file, place it under your "
                    "source root directory.")
    return blade_root_dir


#------------------------------------------------------------------------------
# >>>>>>                        The Main Entry                           <<<<<<
#------------------------------------------------------------------------------

def _main():
    cmd_options = CmdOptions()
    targets = cmd_options.get_args()
    options = cmd_options.get_options()
    if not targets:
        targets = ['.']

    # Set global current_source_dir to the directory which contains the
    # file BLADE_ROOT, is upper than and is closest to the current
    # directory.  Set working_dir to current directory.
    global current_source_dir
    working_dir = os.getcwd()
    current_source_dir = _find_blade_root_dir(working_dir)
    os.chdir(current_source_dir)
    if current_source_dir != working_dir:
        print "Blade: Entering directory `%s'" % current_source_dir
        sys.stdout.flush() # make sure output before scons if redirected

    # Load targets specified in command line and their dependencies by
    # loading and running related BUILD files as Python scripts.
    related_targets = _load_targets(targets, working_dir, current_source_dir)

    # For each loaded target, expand its 'deps' property to include
    # all its direct and/or indirect dependencies.
    deps_expander = DependenciesExpander(related_targets)
    deps_expander.expand_deps()
    targets = deps_expander.get_targets()

    generator = SconsRulesGenerator('SConstruct',
                                    targets,
                                    options)
    generator.output()

    if options.scons_only:
        return 0

    try:
        if options.clean:
            p = subprocess.Popen(
                "scons --duplicate=soft-copy -c -s --cache-show", shell = True)
            p.wait()
            return p.returncode

        p = subprocess.Popen(
            "scons --duplicate=soft-copy -Q -j %s --cache-show" % options.jobs,
            shell = True)
        try:
            p.wait()
            if p.returncode:
                return p.returncode
        except: # KeyboardInterrupt
            return 1

        if options.test:
            test_runner = TestRunner(targets, options)
            return test_runner.run()
    finally:
        try:
            os.remove('SConstruct')
        except:
            pass

    return 0


def main():
    exit_code = 0
    try:
        exit_code = _main()
    except SystemExit, e:
        exit_code = e.code
    except KeyboardInterrupt:
        _error_exit("keyboard interrupted", -signal.SIGINT)
    except:
        _error_exit(traceback.format_exc())
    sys.exit(exit_code)


if __name__ == "__main__":
    main()
