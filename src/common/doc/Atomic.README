陈峰 <phongchen@tencent.com>

提供对基本数据类型的原子操作。

接口：
	分为两层，函数级和对象级。

	函数型接口：

		原子地读取值：
			T AtomicGet(T& target);
			目前常见的体系结构下，不超过 CPU 字长的读取总是原子的。

		原子地修改值：
			T AtomicSet(T& target, T value);	
			操作：
				atomically { return target = value; }
			* atomically 表示该组操作是原子地执行的，并非 C++ 关键字，下同。

			T AtomicAdd(T& target, T value);
			操作：
				atomically { return target += value; }

			T AtomicSub(T& target, T value);
			操作：
				atomically { return target -= value; }

			T AtomicAnd(T& target, T value);
			操作：
				atomically { return target &= value; }

			T AtomicOr(T& target, T value);	
			操作：
				atomically { return target |= value; }

			T AtomicXor(T& target, T value);	
			操作：
				atomically { return target ^= value; }

		原子地修改值并返回修改前的值：
			T AtomicExchangeSet(T& target, T value);
			操作：
				atomically 
				{ 
					T old = target;
					target = value; 
					return old;
				}

			T AtomicExchangeAdd(T& target, T value);
			操作：
				atomically 
				{ 
					T old = target;
					target += value; 
					return old;
				}

			T AtomicExchangeSub(T& target, T value);
			操作：
				atomically 
				{ 
					T old = target;
					target -= value; 
					return old;
				}

			T AtomicExchangeAnd(T& target, T value);
			操作：
				atomically 
				{ 
					T old = target;
					target &= value; 
					return old;
				}

			T AtomicExchangeOr(T& target, T value);
			操作：
				atomically 
				{ 
					T old = target;
					target |= value; 
					return old;
				}

			T AtomicExchangeXor(T& target, T value);
			操作：
				atomically 
				{ 
					T old = target;
					target |= value; 
					return old;
				}

		原子地比较并交换：
			bool AtomicCompareExchange(T& value, T compare, T exchange, T& old)

			操作：
				atomically
				{
					old = value;
					if (value == compare)
					{
						value = exchange;
						return true;
					}
					return false;
				}

	对象型接口：
		对象型接口是在函数型接口的基础上封装的。

		template <typename T>
		class Atomic
		{
		public:
			Atomic();
			template <typename U> Atomic(U value);
			operator T();
			operator const T() const;
			template <typename U> Atomic<T>& operator=(U value);
			T operator++();
			T operator++(int);
			T operator--();
			T operator--(int);
			template <typename U> T operator+=(U rhs);
			template <typename U> T operator-=(U rhs);
			template <typename U> T operator&=(U rhs);
			template <typename U> T operator|=(U rhs);
			template <typename U> T operator^=(U rhs);
			template <typename U> T Exchange(const U value);
			T Increment();
			T Decrement();
			template <typename U> T ExchangeAddWith(U rhs);
			template <typename U> T ExchangeSubWith(U rhs);
			template <typename U> T ExchangeAndWith(U rhs);
			template <typename U> T ExchangeOrWith(U rhs);
			template <typename U> T ExchangeXorWith(U rhs);
			template <typename U> T AddWith(U rhs);
			template <typename U> T SubWith(U rhs);
			template <typename U> T AndWith(U rhs);
			template <typename U> T OrWith(U rhs);
			template <typename U> T XorWith(U rhs);
			template <typename U, typename V> bool CompareExchange(U compare, V exchange, T& old);
		};

		所有的运算符重载都返回运算后的结果（出于性能考虑，不同于常规的值对象语义），
		成员函数等同于同名的 Atomic 函数。
		使用的时候，定义一个 Atomic<Type> 类型的对象，对其的上述操作都能保证是原子的，范例：
			Atomic<int> count;
			++count;

支持的数据类型：
	x86：
		bool,
		char, signed char, unsigned char, 
		wchar_t,
		short, unsigned short, 
		int, unsigned int, 
		long, unsigned long,
		long long, unsigned long long,
		float, double.

		其中bool, float, double 受自身数据类型限制，不能使用所有的接口。

	x64:
		Windows 下支持
		int, unsigned int, 
		long, unsigned long,
		Linux 尚未支持。
	IA64：
		Windows 下支持
		int, unsigned int, 
		long, unsigned long,
		Linux 不支持。

头文件：
	函数型接口，包含 Atomic.h
	对象型接口，包含 Atomic.hpp

库文件：
	不需要

配置：
	不需要

参考资料：

	Intel® 64 and IA-32 Architectures Software Developer's Manuals：
	http://www.intel.com/products/processor/manuals/

	Visual C++ Language Reference Compiler Intrinsics：
	http://msdn.microsoft.com/en-us/library/26td21ds.aspx

	Linux kernel Documentation: Semantics and Behavior of Atomic and Bitmask Operations
	http://www.mjmwired.net/kernel/Documentation/atomic_ops.txt

	GCC-Inline-Assembly-HOWTO:
	http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html

	C++ 0x Working Draft: Chapter 29 Atomic operations library
	http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2738.pdf

不尽之处，请参考 atomic_test.cpp 中的范例。

