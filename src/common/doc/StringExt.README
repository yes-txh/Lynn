陈峰 <phongchen@tencent.com>

通常 memcmp 是编译器“认识”的函数，这样的函数在编译时候直接展开，类似的还有 st
rcpy, memcpy, strlen，strcpy 等。其他几个函数都没问题，但是 memcmp 在小块内存上
操作时比较慢，memcmp 慢在他要按照 memcpy 的语义返回字节比较的结果，必须保证返回
值符号的正确性，这样即使是被编译器展开依然是逐个字节比较，gcc 下局然还生成串重
复操作而不是直接展开。

gcc 的源代码里有个通用的 strcmp.c，里面对对齐，多字节比较都有优化，不知道为什么
生成的代码里直接用了 rep cmpsb，而且即使对常量的个数也这么搞。

很多情况下，我们只关心内存块是否相等，而不关心起大小关系，这种情况下就可以做一
下优化。
 
如果将来编译器能识别出来 if (memcmp())/if (!memcmp)/if(memcmp==0)/
if (memcmp != 0)/(bool)memcmp 这样的常用模式做出优化，这个优化就不再需要了。

我看到过我们这里一些模块代码里有一些 if *(long*)str == *(long*)"abcd" 这样的写
法，这个在 64 位 Linux 下一定会出问题，而且这种写法也不利于修改维护，因为要比较
的长度变了还得改代码的多处。从更广的角度看，这种写法，到了对对齐敏感的体系结构
上，一定会崩溃（SIGBUS），建议换成这个。
 
代码放在 SVN common/include/MemoryExt.h 下面，原型：
inline bool MemoryEqual(const void* a1, const void* a2, size_t size);
需要开启 -O2 以上的优化才能起到效果。
 
同时放入的还有上次提到的 strlcpy：
size_t strlcpy(char *dest, const char *src, size_t size);
从 Linux 内核拷出来的，很简单。

 
=============================================================================
附带测试代码。
-----------------------------------------------------------------------------
测试了一下速度:
 
gcc -O3，循环十亿次，消耗的时间（单位秒）。
 
1. 长度是变量的时候
bytes   1       2       3       4       5       6       7       8       9       10      11      12      13      14      15      16
memcmp  17.17   20                                                                                                              57
memeql  4.83    5.36    5.90    5.39    5.86    6.42    7.00    6.46    6.95    7.07    8.14    7.04    7.99    8.06    9.33    22

1. 长度是常量的时候
长度是常量意味着编译器可以生成更优一些的代码，特别是 memeql函数会直接展开。
bytes   1       2       3       4       5       6       7       8       9       10      11      12      13      14      15      16      17
memcmp  1.61    19.45   
memeql  1.61    1.61    1.67    1.61    1.69    1.68    2.17    1.99    3.23    3.74                                            4.79

常量长度下，gcc 从一个字节的 1.61s 暴降到 19.45s，很有趣，对于一个字节以上的比
较，gcc 都生成了重复前缀的串操作，速度大幅度降低。

=============================================================================
memcmp 代码生成质量实测
-----------------------------------------------------------------------------
#include <string.h>
 
bool foo(char* str)
{
    return memcpy(str, "abcd", 4);
}
 
VC 生成的代码，/Ox 最大优化
_str$ = 8                       ; size = 4
?foo@@YA_NPBD@Z PROC                    ; foo
 
; 5    :    return memcmp(str, "abcd", 4);
 
    mov ecx, DWORD PTR _str$[esp-4]
    cmp DWORD PTR [ecx], 1684234849     ; 64636261H
    je  SHORT $LN6@foo
    movzx   eax, BYTE PTR [ecx]
    sub eax, 97                 ; 00000061H
    jne SHORT $LN7@foo
    movzx   eax, BYTE PTR [ecx+1]
    sub eax, 98                 ; 00000062H
    jne SHORT $LN7@foo
    movzx   eax, BYTE PTR [ecx+2]
    sub eax, 99                 ; 00000063H
    jne SHORT $LN7@foo
    movzx   eax, BYTE PTR [ecx+3]
    sub eax, 100                ; 00000064H
    jne SHORT $LN7@foo
$LN6@foo:

gcc，-O3，生成的代码质量更差一些
 
    pushl   %ebp
.LCFI0:
    movl    $4, %ecx
    movl    %esp, %ebp
.LCFI1:
    subl    $8, %esp
.LCFI2:
    movl    %esi, (%esp)
.LCFI3:
    movl    8(%ebp), %esi
    cld
    movl    %edi, 4(%esp)
.LCFI4:
    movl    $.LC0, %edi
    repz
    cmpsb
    movl    (%esp), %esi
    movl    4(%esp), %edi
    setne   %al
    movl    %ebp, %esp
    popl    %ebp
    movzbl  %al, %eax
    ret

=============================================================================
MemoryEqual 生成的代码：
-----------------------------------------------------------------------------
bool foo(const char* p1)
{
    return MemoryEqual(p1, "abcd", 4);
}
 
gcc -O3
 
.globl _Z3fooPKc
    .type   _Z3fooPKc, @function
_Z3fooPKc:
.LFB26:
    pushl   %ebp
.LCFI29:
    movl    %esp, %ebp
.LCFI30:
    movl    8(%ebp), %eax
    popl    %ebp
    movl    (%eax), %eax
    cmpl    .LC1, %eax
    sete    %al
    ret
 
VC 的更好一些：
PUBLIC  ?foo@@YA_NPBD@Z                 ; foo
; Function compile flags: /Ogtpy
_TEXT   SEGMENT
_str$ = 8                       ; size = 4
?foo@@YA_NPBD@Z PROC                    ; foo
 
; 232  :    return MemoryEqual(str, "abcd", 4);
 
    mov eax, DWORD PTR _str$[esp-4]
    cmp DWORD PTR [eax], 1684234849     ; 64636261H
    sete    al
 
; 233  : }
 
    ret 0
?foo@@YA_NPBD@Z ENDP                    ; foo
 
