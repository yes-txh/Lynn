1. Thread

class Thread : public ::BaseThread
{
public:
    typedef void (*StartRoutine)(void* context, void* param);
public:
    Thread(
        StartRoutine start_routine, 
        void* context = NULL, 
        void* param = NULL
    );
    Thread(){}
    void Initialize(
        StartRoutine start_routine,
        void* context = NULL,
        void* param = NULL
    );
};

使用 MAKE_THREAD_CALLBACK 或者 MAKE_PARAMETERIZED_THREAD_CALLBACK 宏，可以把普通成员函数作为线程函数传给 Thread。

/// 把类成员函数转为普通函数用来做线程回调函数
/// @param Class 类名
/// @param Member 成员函数名
/// 例如存在成员函数：@code
/// void Test::XxxThread();
/// @endcode
/// 用 MAKE_MEMBER_CALLBACK(Test, XxxThread)，既可生成可用于线程的函数指针，类型为@code
/// void (*)(void* object, void* param)
/// @endcode
/// 注意开头多了一个参数，用来传递 this 指针。
#define MAKE_THREAD_CALLBACK(Class, Member) &::GenericMemberFunctionAdapter<Class, &Class::Member>

/// 把带一个参数的类成员函数转为普通函数用来做回调。            
/// @param Class 类名                                           
/// @param Member 成员函数名                                    
/// @param ParamType 成员函数的参数类型，只能是指针或者 intptr_t/uintptr_t
/// 例如存在成员函数：@code                                     
/// void Test::XxxThread(void* param);
/// @endcode
/// 用 MAKE_MEMBER_CALLBACK(Test, XxxThread)，既可生成可用于线程的函数指针，类型为@code
/// void (*)(void* object, void* param)
/// @endcode
/// 注意开头多了一个参数，用来传递 this 指针。
#define MAKE_PARAMETERIZED_THREAD_CALLBACK(Class, Member, ParamType) &::GenericParamMemberFunctionAdapter<Class, ParamType, &Class::
Member> 

2. ThreadPool
util/include/ThreadPool.hpp

class ThreadPool
{
public:
    ///< 统计信息
    struct Stat
    {
        size_t NumThreads;              ///< 总的线程数
        size_t NumBusyThreads;          ///< 忙的线程数
        size_t NumPendingTasks;         ///< 尚未完成的 task 的数目
    };
public:
    ThreadPool(
        int min_threads = 0,            ///< 最小线程数，线程小于这个数目，新加任务会创建新线程，-1 代表使用系统逻辑cpu个数。
        int max_threads = -1,           ///< 最大线程数，线程多于这个数目，就不在创建新线程，-1 代表使用系统逻辑cpu个数。
        int idle_timeout = 1000         ///< 线程持续空闲 idle_timeout，如果大于最小线程数，就会退出
    );
    ~ThreadPool();                      ///< 自动调 Terminate();
    void SetMinThreads(size_t size);    ///< 设置最小线程数
    void SetMaxThreads(size_t size);    ///< 设置最大线程数
    void SetIdleTime(time_t time);      ///< 设置允许的空闲时间
    void AddTask(
        Thread::StartRoutine routine,   ///< void (*)(void* context, void* param)
        void* context = NULL,           ///< 函数的 context 参数
        void* param = NULL              ///< 函数的 param 参数
    );
    void Terminate(
        bool wait = true,               ///< 表示是否等待尚未完成的任务
        int timeout = -1                ///< 等待的超时
);
    void GetStat(Stat& stat) const;     ///< 获得统计信息
};

使用范例：

// 参数在 param 中
void test(void*, void* param)
{
    printf("%d\n", (int)intptr_t(param));
    usleep(100000);
}

UNIT_TEST_CASE(GlobalFunction)
{
    ThreadPool threadpool(4, 4);
    for (int i = 0; i < 10; ++i)
    {
        for (int j = 0; j < 20; ++j)
        {
            threadpool.AddTask(test, NULL, (void*)(i*20+j)); // 把整数值作为第二个参数传递给 test 函数
            ThreadPool::Stat stat;
            threadpool.GetStat(stat);
            printf("%d: NumThreads=%zu, NumBusyThreads=%zu, NumPengdingTasks=%zu\n",
                   i*20+j, stat.NumThreads, stat.NumBusyThreads, stat.NumPendingTasks);
        }
    }
}

class Foo
{
public:
    void test1()
    {
        printf("test1\n");
        usleep(100000);
    }
    void test2(intptr_t param)
    {
        printf("%zd\n", param);
        usleep(100000);
    }
};

UNIT_TEST_CASE(MemberFunction)
{
    ThreadPool threadpool(4, 4);
    Foo foo;
    for (int i = 0; i < 10; ++i)
    {
        for (int j = 0; j < 20; ++j)
        {
            /// 调用无参数的 foo::test1 函数
            threadpool.AddTask(MAKE_THREAD_CALLBACK(Foo, test1), &foo);

            /// 调用有一个参数的 foo::test2 函数
            threadpool.AddTask(MAKE_PARAMETERIZED_THREAD_CALLBACK(Foo, test2, intptr_t), &foo, (void*)(i*20+j));
            ThreadPool::Stat stat;
            threadpool.GetStat(stat);
            printf("%d: NumThreads=%zu, NumBusyThreads=%zu, NumPengdingTasks=%zu\n",
                   i*20+j, stat.NumThreads, stat.NumBusyThreads, stat.NumPendingTasks);
        }
    }
}
