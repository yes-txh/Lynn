				LargeFile 大文件读写

标准 C 的 IO 函数设计时，最大的整数数据类型是 long，所以 ftell, seek 设计时偏移量用了 long，
未曾想到会有一天会有 4G 以上的大文件，等到出现时，原型再改起来麻烦了，所以都引入了新函数：
VC 下用 _ftelli64, _fseeki64，
gcc 用 ftello64, feeko64，当 #define _FILE_OFFSET_BITS 64 的时候，也可以用 ftello, feeko。
为了方便，堆砌进行了封装以屏蔽差异。
 
封装很薄，因此不需要链接额外的库。
 
// 支持 4G 以上的大文件读写和定位
class LargeFile
{
public:
    // 空
    LargeFile() : m_fp(NULL){}
 
    // 打开文件，失败会 throw std::runtime_error 异常
    LargeFile(const char* filename, const char* mode);
 
    // 析构时关闭文件
    ~LargeFile();
 
    // 打开文件，同 fopen，失败会返回错误，错误原因位于 errno 中。
    bool Open(const char* filename, const char* mode);
 
    // 关闭文件
    void Close();
 
    // 获取持有的 FILE*
    FILE* GetFp() const;
 
    // 是否持有有效的 FILE*。
    bool IsValid();
 
    // 从外部设置 FILE*，由 LargaeFile 管理，原有的 fp 会被关闭。
    void Attach(FILE* fp);
 
    // 从对象中分离 FILE*，分离后对象变为无效。
    FILE* Detach();
 
    // 读取，同 fread
    size_t Read(void* buffer, size_t element_size, size_t element_count);
 
    // 写入，同 fwrite
    size_t Write(const void* buffer, size_t element_size, size_t element_count);
 
    // 返回当前文件偏移量
    long long Tell() const;
 
    // 定位文件偏移量
    bool Seek(long long offset, int whence = SEEK_SET);
 
    // 定位文件偏移量到起始位置
    void Rewind();
 
public: // 不允许拷贝
    LargeFile(const LargeFile&);
    LargeFile& operator=(const LargeFile&);
private:
    FILE* m_fp;
};

 
封装主要是针对 ftell 和 feek 的接口差异，如果是顺序的读入和写出，倒是无所谓。
 