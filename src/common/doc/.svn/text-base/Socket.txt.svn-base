// Socket 异常对象
class SocketError : public std::runtime_error
{
public:
	SocketError():
	int Code();
};

/// 抽象的 Socket Address
class SocketAddress
{
public:
	// 返回地址家族
	virtual sa_family_t Family() const = 0;

	// 转为 sockaddr* 类型
	virtual sockaddr* Address() = 0;        /// sockaddr*
	virtual const sockaddr* Address() const = 0;

	// 返回地址的长度
	virtual socklen_t Length() const = 0;

	// 对于长度可变的地址，设置长度，否则如果设置的长度不等于协议规定的长度，返回 false
	virtual bool SetLength(socklen_t length) = 0;

	// 对于长度可变的地址，返回最多能设置的地址长度
	virtual socklen_t Capacity() const = 0;

	// 转换为字符串
	virtual std::string ToString() const = 0;

	// 从字符串解析得到地址
	virtual bool Parse(const char* str) = 0;
};

// IP 地址类，封装 IPv4 地址
class IPAddress
{
public:
	// 创建空 IP 地址对象
	IPAddress()

	// 从字符串创建 IP 地址对象，如果字符串无效，会抛出异常
	explicit IPAddress(const char* src);
	explicit IPAddress(const std::string& src);

	// 从网络字节序的无符号整数构建 IP 地址对象
	explicit IPAddress(unsigned int ip)

	// 四个单字节整数构建 IP 地址对象
	IPAddress(unsigned char b1, unsigned char b2,unsigned char b3,unsigned char b4)

	// 从 in_addr 结构构建对象
	IPAddress(in_addr addr)
public:
	// 赋值，网络字节序
	void Assign(unsigned int ip) // network byte order
	void Assign(in_addr addr)
	void Assign(unsigned char b1, unsigned char b2,unsigned char b3,unsigned char b4)

	// 赋值，从字符串
	bool Assign(const char* src)
	bool Assign(const std::string& src)
	in_addr_t ToInt() const
	const in_addr ToInAddr() const
	const std::string ToString() const
public:
	// 特殊 IP 地址

	// 无效地址
	static const IPAddress None();

	// 任意地址
	static const IPAddress Any();

	// 广播地址
	static const IPAddress Broadcast();

	// 回环地址
	static const IPAddress Loopback();
};

// 比较运算符
bool operator==(const IPAddress lhs, const IPAddress rhs);
bool operator<(const IPAddress lhs, const IPAddress rhs);

// IPv4 的 Socket 地址，从 SocketAddress 类派生。
class SocketAddressInet4 : public SocketAddress
{
public:
	// 构建空地址
	SocketAddressInet4();

	// 从 IP 和端口构建 SocketAddress，ip 是网络字节序，port 是本地字节序
	SocketAddressInet4(unsigned int ip, unsigned short port);

	// 从 IP 和端口构建 SocketAddress，port 是本地字节序
	SocketAddressInet4(const IPAddress ip, unsigned short port);

	// 从四个字节和端口创建对象
	SocketAddressInet4(unsigned char b1, unsigned char b2, unsigned char b3, unsigned char b4, unsigned short port);

	// 从字符串创建对象，格式为“xxx.xxx.xxx.xxx:port”
	SocketAddressInet4(const char* src);
	SocketAddressInet4(const std::string& src);

	// 从IP地址字符串和端口创建对象
	SocketAddressInet4(const char* src, unsigned short port)
	SocketAddressInet4(const std::string& src, unsigned short port)

	// 转为点分十进制的IP加上冒号和字符串格式
	std::string ToString() const;

	// 解析地址字符串，格式为“xxx.xxx.xxx.xxx:port”
	bool Parse(const char* src);

	// 赋值，参数含义同构造
	bool Assign(unsigned int ip, unsigned short port)
	bool Assign(const IPAddress ip, unsigned short port);
	bool Assign(unsigned char b1, unsigned char b2, unsigned char b3, unsigned char b4, unsigned short port);
	bool Assign(const char* str);
	bool Assign(const char* str, unsigned short port);
	bool Assign(const std::string& ip, unsigned short port);
	bool Assign(const std::string& src);

	// 单独设置 IP
	void SetIP(const IPAddress address);

	// 获取 IP
	const IPAddress GetIP() const;

	// 获取端口
	unsigned short GetPort() const;

	// 单独设置端口
	void SetPort(uint16_t port);
};

// Unix 域 socket 地址
class SocketAddressUnix : public SocketAddress
{
public:
	SocketAddressUnix(const char* name);
	SocketAddressUnix(const std::string& name);
	std::string ToString() const;
	bool Parse(const char* name);
};

// 用于存储类型任意 Socket 地址的对象
class SocketAddressStorage : public SocketAddress
{
public:
	SocketAddressStorage();
	virtual sa_family_t Family() const;
	virtual sockaddr* Address();
	virtual socklen_t Length() const;
	virtual bool SetLength(socklen_t length);
	virtual socklen_t Capacity();
	virtual std::string ToString() const;
	virtual bool Parse(const char* str);
};

// 跨平台的 socket fd 的类型定义。
typedef ... SOCKET;

/// 抽象的 Socket 类，不可构建。
class Socket
{
public:
	// 无效 Socket 类型
	static const SOCKET InvalidHandle = INVALID_SOCKET;
protected:
	// 空 socket
	Socket();

	// 绑定到已存在的 socket fd
	explicit Socket(SOCKET handle);

	// 创建新的 socket 对象
	bool Create(int af, int type, int protocol = 0);
public:
	// 返回封装的 socket fd
	SOCKET Handle() const;

	// 发挥是否持有了有效的 socket fd
	bool IsValid() const;

	// 绑定已存在的 fd 到 socket 对象
	void Attach(SOCKET handle)

	// 解除所封装的 fd 和对象的绑定，并返回
	SOCKET Detach();

	// 关闭 socket
	bool Close()

	// 获取和设置不同类型的 socket 选项
	bool GetOption(int level, int name, void* value, socklen_t& length) const;
	template <typename T>
	bool GetOption(int level, int name, T& value) const
	template <typename Type, typename InternalType>
	bool GetOption(int level, int name, Type& value) const
	bool GetOption(int level, int name, bool& value) const

	// 设置 socket 选项
	bool SetOption(int level, int name, const void* value, socklen_t length);
	template <typename T>
	bool SetOption(int level, int name, const T& value)
	template <typename Type, typename InternalType>
	bool SetOption(int level, int name, const Type& value)
	bool SetOption(int level, int name, const bool& value)

	// 获得 socket 的错误码
	bool GetError(int& error)

	// 获取 socket 的类型
	bool GetType(int& type)

	// 获得发送缓冲区的大小
	bool GetSendBufferSize(size_t& size)

	// 设置发送缓冲区的大小
	bool SetSendBufferSize(size_t& size)

	// 获得接收缓冲区的大小
	bool GetReceiveBufferSize(size_t& size)

	// 设置接收缓冲区的大小
	bool SetReceiveBufferSize(size_t& size)

	// 设置阻塞模式，默认为设置为阻塞
	bool SetBlocking(bool value = true);

	// 获取是否设置为阻塞模式
	bool GetBlocking(bool &value);

	// 绑定到指定地址
	bool Bind(const SocketAddress& address);

	// 获得本地地址
	bool GetLocalAddress(SocketAddress& address) const;

	// 获得连接的远端地址
	bool GetPeerAddress(SocketAddress& address) const;

	// 获取是否重用地址
	bool GetReuseAddress(bool &value);

	// 设置是否重用地址
	bool SetReuseAddress(bool value = true)

	// 等待可读事件
	bool WaitReadable(struct timeval* tv = NULL, bool restart = true)
	bool WaitReadable(struct timeval& tv, bool restart = true)

	// 等待可写事件
	bool WaitWritable(struct timeval* tv = NULL, bool restart = true)
	bool WaitWritable(struct timeval& tv, bool restart = true)

	// 返回 socket 是否可读
	bool IsReadable();

	// 返回 socket 是否可写
	bool IsWritable();
};

// 监听 socket
class ListenerSocket : public Socket
{
public:
	// 空 socket，需要后续 create
	ListenerSocket();

	// 创建监听 socket
	ListenerSocket(int af, int type, int protocol):

	// 创建监听 socket，同时绑定地址
	ListenerSocket(const SocketAddress& address, int type = SOCK_STREAM):

	using Socket::Create;

	// 开始 listen
	bool Listen(int backlog = SOMAXCONN)

	// 接受连接
	bool Accept(Socket& socket, bool auto_restart = true)

	// 接受连接，同时返回对方地址
	bool Accept(Socket& socket, SocketAddress& address, bool auto_restart = true)
};

// 数据 socket，
class DataSocket : public Socket
{
public:
	// 连接
	bool Connect(const SocketAddress& address, bool auto_restart = true)

	// 发送数据，同 socket 的 send 函数
	bool Send(const void* buffer, size_t buffer_size, size_t& sent_length, int flags = 0, bool auto_restart = true);

	// 接受数据，同 socket 的 recv 函数
	bool Receive(void* buffer, size_t buffer_size, size_t& received_size, int flags = 0, bool auto_restart = true);

	// 带超时的接收
	bool Receive(void* buffer, size_t buffer_size, size_t& received_size, timeval& timeout, int flags = 0, bool auto_restart = true)
};

// 流 socket
class StreamSocket : public DataSocket
{
public:
	StreamSocket(){}
	explicit StreamSocket(int af, int protocol)

	/// Create a stream socket
	bool Create(sa_family_t af = AF_INET, int protocol = 0)

	// 关闭连接
	bool Shutdown();
	/// shutdown connection sending
	bool ShutdownSend();
	/// shutdown connection receiving
	bool ShutdownReceive();

	// 接收完指定长度的数据，除非出错
	bool ReceiveAll(void *buffer, size_t buffer_size, size_t& received_size, int flags = 0, bool auto_restart = true)
	bool ReceiveAll(void *buffer, size_t buffer_size, int flags = 0, bool auto_restart = true)
	bool ReceiveAll(void *buffer, size_t buffer_size, size_t& received_size, timeval& timeout, int flags = 0, bool auto_restart = true)
	bool ReceiveAll(void *buffer, size_t buffer_size, timeval& timeout, int flags = 0, bool auto_restart = true)

	// 发送整个缓冲区的数据，除非出错
	bool SendAll(const void* buffer, size_t buffer_size, size_t& sent_size, int flags = 0, bool auto_restart = true)
	bool SendAll(const void* buffer, size_t buffer_size, int flags = 0, bool auto_restart = true)

	// 接收一个文本行的数据，除非出错或者缓冲区满
	bool ReceiveLine(void* buffer, size_t buffer_size, size_t& received_size, size_t max_peek_size = 80)

	// 接收一个文本行的数据，除非出错
	bool ReceiveLine(std::string& str, size_t peek_size = 80)
};

// 数据报 socket
class DatagramSocket : public DataSocket
{
public:
	DatagramSocket(int af, int protocol = 0)
	DatagramSocket()
	bool Create(int af = AF_INET, int protocol = 0)
	bool ReceiveFrom(void* buffer, size_t buffer_size, size_t& received_size, SocketAddress& address, int flags = 0)
	bool SendTo(const void* buffer, size_t buffer_size, const SocketAddress& address, size_t& sent_size)
};


更多的例子，参考 Base/test/echo_server.cpp 和 Base/test/telnet/server.cpp
