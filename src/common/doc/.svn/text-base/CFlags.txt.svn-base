[本文档位置]
https://tc-svn/setech/setech_twsedownload_rep/dl_common_proj/trunk/doc/CFlags.txt

CFlags 是一个非集中的命令行处理库，也就是说，命令行选项可以分布在源代码的
不同地方，不需要全局统一定义在一起，能够减少代码的耦合。

CFlags 库提供了一组函数用来解析，检查，输出所有的选项，以及自动生成帮助。

CFlags 自动把命令行中的选项填充到用户定义的 flag 里，并能对数据进行严格的有效性检查。

头文件在：
util/include/CFlags.hpp

测试程序兼范例：
util/test/test_cflags.cpp

【使用 CFlags 库】

[定义命令行标志]

#include "CFlags.hpp"

定义成全局变量，静态全局变量，静态类成员变量都可以。
但是不能是局部变量（包括局部静态变量）。

CFlags::Flag<std::string> Flag_username(
	__FILE__,                   ///< 用于诊断
	"username",                 ///< flag 名
	"username of the system"    ///< 描述信息，用于生成帮助
);

还可以指定默认值
CFlags::Flag<std::string> Flag_username(
	__FILE__, 
	"username",
	CFlags::DefaultIs("chen3feng"),                ///< 默认值
	"username of xxx"
);

还可以指定必需配置，不能有默认值
CFlags::Flag<std::string> Flag_username(
	__FILE__, 
	"username",
	"username of xxx",
	CFlags::NoDefault
);

默认情况下，值存放在 Flag 对象内部，可以通过 Value 成员函数读取和写入。
但是也可以放在外面，依然可以通过 Value 成员函数读取和写入：

std::string username; ///< 外部的配置变量。
CFlags::Flag<std::string> Flag_username(
	__FILE__, 
	"username",
	CFlags::BindTo(&username),   ///< 配置项的值放在外面，把它的地址传过去即可。
	"username of xxx",
	CFlags::NoDefault
);

[简化方式]

使用宏
CFLAGS_DEFINE_FLAG(type, name, ...)

生成类型为 CFlags::Flag<type>，名字为 Flag_ + name，flag 名字为

后面的参数同 Flag 的构造函数，只是开头的文件名和行号以及选项名不需要了，例如
CFLAGS_DEFINE_FLAG(
	std::string, 
	username, 
	"username of the system", 
	CFlags::NoDefault
);
等效于
CFlags::Flag<std::string> Flag_username(
	__FILE__, 
	"username",
	"username of xxx",
	CFlags::NoDefault
);

此外还有配套的
CFLAGS_DECLARE_FLAG(type, name) 相当于
extern CFlags::Flag<type> Flag_##name
用于头文件中声明全局变量。

用 Flag::Value() 成员函数访问 flag 的实际值。

Flag<T> 类型也重载了 operator T& ，能用于大部分能用 T 类型的场合。

[格式]

--选项名[=值]，= 和值只有在后面的参数也是 flag 的时候才可以省略。
比如 --delete --create --username=chen3feng --size=1000

[数据类型]
bool: 有效值为 true, false, on, off, yes, no, 或者为空，为空的时候等于 true
比如 --delete=yes --delete 是等效的。

各种整数，支持十进制整数和十六进制，十六进制要加 0x 前缀，比如：
--block-size=0x2000

浮点数：支持 float 和 double

字符串：字符串类型

还可以扩充数据类型，只需特化模板 CFlags::FlagHandler 即可。

特化的 CFlags::FlagHandler 要求含有下列两个成员函数：

static bool Parse(const char* value, T* result, std::string& error_message);
用于解析字符串，字符串的值为 value，解析的结果放到 *result 中。
如果成功，返回 true，否则应该返回 false，并设置 error_message 为恰当的错误描述。

static std::string ToString(const T* value);
把 *value 表示的值转为字符串。

范例：

/// 演示数据类型扩充：支持复数类型
namespace CFlags
{
template <typename T>
struct FlagHandler<std::complex<T> >
{
public:
	static bool Parse(const char* value, std::complex<T>* result, std::string& error_message)
	{
		double real = 0, image = 0;
		if (sscanf(value, "%lf+%lfi", &real, &image) == 2 || // 数学格式
			sscanf(value, "%lf+%lfj", &real, &image) == 2 || // 电工格式
			sscanf(value, "(%lf,%lf)", &real, &image) == 2 || // 民工格式
			sscanf(value, "%lf", &real) == 1 ||
			sscanf(value, "%lfi", &image) == 1 ||
			sscanf(value, "%lfj", &image) == 1
		)
		{
			*result = std::complex<T>(real, image);
			return true;
		}

		error_message = "invalod complex format";
		return false;
	}
	static std::string ToString(const std::complex<T>* value)
	{
		char buffer[64];
		return std::string(buffer, sprintf(buffer, "%lg+%lgi", value->real(), value->imag()));
	}
};
}

[内置选项]

CFlags 支持一组内置 flag，列出如下：
--flagfile=filename
  从文件加载配置，文件的格式是每行一个选项，比如 xxx.conf:

  --flagfile=xxx.conf

  xxx.conf 范例如下：
  # 开头的行是注释
  --login
  --username=chen3feng

--ignore_unknown[=bool_value]
  忽略未知的 flags，等效于解析时的 IgnoreUnknown 标志，但是命令行指定的优先级更高，
  出现多个 ignore_unknown 选项时，最后一个起作用。
  ignore_unknown 选项带一个可选的 bool 值。

--help
  显示帮助信息

[校验机制]
CFlags 支持校验机制，描述信息和额外标志后可以再跟一个函数指针，用来检查值的有效性。
函数原型要求为：
bool Validator(const T* value, std::string& error_message);
返回 true 表示没有错误。
返回 false 表示错误，error_message 设置为恰当的错误信息。

范例：
校验 listen 端口范围是否在非 root 程序可 listen 的有效范围之内

bool ValidateListenPort(const unsigned short* port, std::string& error_message)
{
    // 1024 以下为特权端口，非 root 程序不能 listen
    // 32768-61000 为 Linux 系统动态分配范围，可能冲突。
    if ((*port > 1024 && *port < 32768) || *port > 61000)
        return true;
    error_message = "invalid listen port value, should between (1024, 32768) or (61000, 65536)";
    return false;
}

CFLAGS_DEFINE_FLAG(unsigned short, port, "port number", 0, ValidateListenPort);

如果输入错误的值，就会被检测到：
./test_cflags --port=1020
Command error:
  Parse error(s):
    '--port' validate error: invalid listen port value, should between (1024, 32768) or (61000, 65536), value='1020'

【CFlags API】

1. Dump 所有的 flag 的值
void CFlags::DumpValues(FILE* stream);

输出范例：

Current flag values:
        --create=false (default)
        --demo=true (default)
        --number= <not initialized>
        --username=chen3feng (default)
        --delete=false (default)
        --overwrite=false (default)
        --PI=3.14159 (default)
        --complex=0+0i (default)
        --complex2=0+0i (default)

2. 显示帮助信息

void CFlags::ShowHelp(const char* app_name, FILE* stream);
app_name 是程序的名字，通常传递 argv[0] 即可。
stream 是输出的目标，通常的显示帮助传递 stdout，认为用户输入错误的时候
应该传递 stderr。

输出范例：

Usage: ./test_cflags <flags> ...
Acceptable flags:
        --create whether create
        --demo whether demo mode
        --number number of xxx
        --username username of xxx
        --delete whether delete
        --overwrite whether overwrite
        --PI PI
        --complex a simple complex demo
        --complex2 another simple complex demo
Acceptable builtin flags:
        --help  show help
        --flagfile      load flags from file


3. 解析命令行

bool CFlags::ParseCommandLine(int *argc, char*** argv, int flags)

argc, argv 是命令行。

flags 支持如下标志，可以用 | 运算符组合起来。
CFlags::Silent         出错时不报告出错信息。
CFlags::IgnoreUnknown  忽略不认识的 flag，默认时则会报错
CFlags::NoRemove       ParseCommandLine 解析识别出 flag 后默认会从参数列表中删除，
                       NoRemove 标志可以阻止这种行为。

范例：
if (CFlags::ParseCommandLine(&argc, &argv))
{
    return EXIT_FAILURE;
}

成功后，程序内所有没有设置 NoDefault 属性的 Flags 应该都得到了设置。

4. 直接加载配置文件

bool CFlags::ParseFlagsFile(const char* app_name, const char* filename, int flags = 0);
app_name 程序的名字，传 argv[0] 即可。
filename 配置文件的名字。
flags 和 error_message 同 ParseCommandLine

[范例]

【原理】
每个 Flags 类型的对象构建时，把自己加入到全局的 FlagList 的单链表里。
CFlags 库就能知道有哪些 Flag 变量，并能集中处理了。

【参考】
google gflags，gflags 对于整数只支持 int32 和 int64/uint64，浮点类型只支持 double 不支持 float，
并且不支持自定义数据类型。
http://code.google.com/p/google-gflags/
